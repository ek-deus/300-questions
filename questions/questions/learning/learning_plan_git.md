# Программа обучения Git
---
hgghgh
hjhgbcde5555467
4w5ydfg
dfhgdfh
dh7kuy

ссылка на страницу курса по Git   https://smartiqa.ru/courses/git

---

Оглавление:

[Глава 1. Что такое Git. Преимущества. Установка и настройка.](#Glava_1)

[Глава 2. Базовая работа с GIT. Коммиты. Индексация. Команды: init, status, add, commit.](#Glava_2)

[Глава 3. Ветвление. Создание, переключение и удаление веток. Команды: branch, checkout, status, log, diff.](#Glava_3)

[Глава 4. Перемещение курсора и отмена изменений. Команды git restore, git rm, git reset, git checkout, git commit, git revert.](#Glava_4)

[Глава 5. Слияние изменений и продвинутая работа с ветками. Команды: merge, cherry-pick, rebase.](#Glava_5)

[Глава 6. Работа с удаленным репозиторием. Модель ветвления. Команды: clone, fetch, push, pull.](#Glava_6)

---

##### <a name="Glava_1"> </a> # Глава 1. Что такое Git. Преимущества. Установка и настройка.

## Определение Git
Git — это система управления версиями с распределенной архитектурой. В отличие от некогда популярных систем вроде CVS и Subversion (SVN), где полная история версий проекта доступна лишь в одном месте, в Git каждая рабочая копия кода сама по себе является репозиторием. Это позволяет всем разработчикам хранить историю изменений в полном объеме.

## Преимущества Git:
1. Все локально. Репозиторий, история, ветки и коммиты. Отсюда вытекает 2 важных следствия: все очень быстро, и второе — вы получаете абсолютный контроль над репозиторием.
2. Контроль. В Git можно делать с коммитами и историей все что угодно
3. Ветки. Git — это ветки. Это настолько просто, гибко и удобно, что все делается в ветках. От релиза, до маленьких задач.
4. Коммит. Чтобы сделать коммит, надо указать какие именно изменения нужно туда положить. Изменения, а не файлы. 
- Перед тем, как делать коммит, можно посмотреть и настроить, какие файлы в него попадут. Например, если вы хотите зафиксировать изменения только в одном файле из целого проекта - Git позволит вам это сделать.
- Вы можете занести в коммит только часть изменения в файле. А остальные изменения откатить, или положить в другой коммит.
- Просмотр истории коммитов и различий в файлах
- Можно посмотреть, какие изменения были внесены в файл в разных коммитах.
- Можно посмотреть историю коммитов всей ветки, чтобы проследить, как менялись файлы.
Последнее время я использую только «git add -p» — Git показывает чанк за чанком (набор изменений в рамках файла) и спрашивает добавить в коммит или нет. Так я вижу, что я изменил и буду коммитить. И поэтому в коммит у меня никогда не попадут отладочный код, комментарии, лишние правки, пробелы. И коммиты получаются четкими и атомарными.
5. Stash - это очень удобная функция Git. Она позволяет заморозить текущие изменения и переключиться на другую ветку.
Например, коллега попросил вас срочно помочь ему с его работой, а у вас множество изменений в файлах, которые еще рано класть в коммит. Вы просто прописываете git stash, после чего переключаетесь на ветку коллеги и помогаете ему. Вам не придется создавать бесполезный коммит, только чтобы сохранить изменения в своих файлах, но при этом вы их и не потеряете при смене ветки.
6. Работа в команде
Вся работа выполняется атомарно в соответствующих ветках. После завершения работы, она отправляется на ревью, и только после этого ветка может быть слита с основной. Это позволяет не допустить присутствие непроверенного кода на основной ветке.
Очень удобно проводить ревью задачи, которая выполнена в отдельной ветке. Посмотреть различия коммитов, что-то исправить, прокомментировать, отправить обратно на доработку, а потом объединить отдельные коммиты и слить в основную ветку.

## Установка Git
Чтобы установить Git в Debian-based систему (напр. Ubuntu) наберите команду в терминале

```bash
sudo apt-get install git
```

## Настройка Git

![](imgs-lp/gitconfig1.png)
![](../imgs/gitconfig1.png)
![<img src="../imgs/gitconfig1.png" width="50%">](../imgs/gitconfig1.png)
![](../imgs/gitconfig1.png)

Порядок приоритета уровней конфигурации следующий: локальный, глобальный, системный. 

Это значит, что при поиске значения конфигурации система Git будет начинать с локального уровня и подниматься до уровня системы.
Чтобы настроить Git на линуксе, вам нужно отредактировать файл ~/.gitconfig. Сделать это можно напрямую через редактор или с помощью утилиты git config (рекомендуется).

Первое, что вам следует сделать после установки Git — указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git содержит эту информацию, и она включена в коммиты, передаваемые вами, и не может быть далее изменена. Добавим их на глобально на уровне пользователя, то есть для всех репозиториев:

```bash
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
```

Чтобы посмотреть все установленные настройки Git, используйте команду:

```bash
git config --list
```

##### <a name="Glava_2"> # Глава 2. Базовая работа с GIT. Коммиты. Индексация. Команды: init, status, add, commit.

Репозиторий – папка проекта, отслеживаемого Git, содержащая дерево изменений проекта в хронологическом порядке. Все файлы истории хранятся в специальной папке .git/ внутри папки проекта.

Индекс – файл, в котором содержатся изменения, подготовленные для добавления в коммит. Вы можете добавлять и убирать файлы из индекса.

Коммит – фиксация изменений, внесенных в индекс. Другими словами, коммит – это единица изменений в вашем проекте. Коммит хранит измененные файлы, имя автора коммита и время, в которое был сделан коммит. Кроме того, каждый коммит имеет уникальный идентификатор, который позволяет в любое время к нему откатиться.

Указатели HEAD, ORIGHEAD и т. д. – это ссылка на определенный коммит. Ссылка – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит.

Ветка – это последовательность коммитов. Технически же, ветка – это ссылка на последний коммит в этой ветке. Преимущество веток в их независимости. Вы можете вносить изменения в файлы на одной ветке, например, пробовать новую функцию, и они никак не скажутся на файлах в другой ветке. Изначально в репозитории одна ветка, но позже мы рассмотрим, как создавать другие.

Рабочая копия. Директория .git/ с её содержимым относится к Git. Все остальные файлы называются рабочей копией и принадлежат пользователю. 

## Создание репозитория. Команда git init

Репозиторий должен обязательно содержать папку .git/ с историей этого репозитория. Создать эту папку можно двумя способами:

1. Создать новый репозиторий.
2. Клонировать к себе на компьютер существующий репозиторий.

Второй способ мы рассмотрим в последующих уроках, а пока займемся первым. Итак, чтобы создать репозиторий, вам понадобится команда git init.

```
Команда git init

Что делает
Создает пустой репозиторий в директории, откуда была вызвана

Формат
git init <параметры>

Пример
# Создаем пустой репозиторий в папке проекта
$ cd projects/project_folder/
$ git init
Initialized empty Git repository in projects/project_folder/
```

Создадим папку test_repository и на ее базе создадим репозиторий Git:

```
mkdir test_repository
cd test_repository/
git init
```

Эта команда создала папку .git внутри папки вашего проекта. По ходу работы мы будем разбираться, чем же наполнена эта папка. А пока приведем структуру ее содержимого:

```bash
Папка test_repository/.git
test_repository/.git
├── HEAD
├── branches
├── config
├── description
├── hooks
├── info
│   └── exclude
├── objects
│   ├── info
│   └── pack
└── refs
    ├── heads
    └── tags
```

Репозиторий Git условно можно разделить на три составляющие:

![](../imgs/gitproject.png)

Таким образом, получается, что ваши файлы путешествуют между этими тремя областями. Файлы, с которыми вы напрямую работаете - это Working Directory. Что-то изменили в этих файлах - изменилось состояние Working Directory.

Хотите зафиксировать эти изменения - скажите Git, какие именно из всех изменений, вы хотите сохранить. Для этого вы добавляете изменения в файлах во вторую область - Staging (он же Index). Это некое среднее состояние между Working Directory и Git Directory - изменения уже на пути к фиксации, но еще не сохранены в базе Git.

Если вы уверены, что все изменения, которые вы добавили в Index / Staging, необходимо сохранить в базу Git, то вы делаете коммит, и они в сжатом виде помещаются в Git Directory. Теперь все надежно сохранено в папке .git.

![](../imgs/gitfiles.png)

Каждый файл может находится только в одном из двух состояний:

1. Отслеживаемый. Об этих файлах Git знает и отслеживает изменения в них. Отслеживаемые файлы в свою очередь могут находится в следующих состояниях:

- Неизмененный. То есть с момента последнего коммита в файле не было никаких изменений
- Измененный. То есть с последнего коммита в файле были произведены какие-то изменения.
- Подготовленный к коммиту. Это значит, что вы внесли изменения в этот файл и затем проиндексировали их, и эти изменения будут добавлены в следующий коммит.

2. Неотслеживаемый. О неотслеживаемых файлах Git не знает, поэтому изменения в них не будут добавлены в коммит. Это любые файлы в вашем рабочем каталоге, которые не входили в последний коммит и не подготовлены к текущему коммиту.

Приведем наглядную визуализацию состояний и переходов между ними.

![](../imgs/gitfiles2.png)

Чтобы посмотреть статус текущих файлов, нам потребуется команда git status. 

```
Команда git status

Что делает
Выводит информацию о статусе файлов, находящихся в репозитории

Формат
git status <флаги>

Пример
# Cмотрим на статус файлов
$ git status

new file: discrete math/hw-3/dm_sem_11_done.pdf
new file: it theory/3/itt_3.pdf
deleted: progrmmings/c/non-evaluated/out.txt

Changes not staged for commit:
(use "git add/rm <file>..." to update what will be committed)
(use "git restore <file>..." to discard changes in working directory)
modified: .gitignore
```

Перейдем к примеру. Создадим в нашем тестовом репозитории два файла: alpha.txt и num.txt. Первый будет содержать букву a, а второй – цифру 1:
```
Папка test_repository
test_repository/
     ├── alpha.txt
     └── num.txt
```

Посмотрим, что при этом покажет команда git status:

```
$ git status

 
On branch develop

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        alpha.txt
        num.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Видно, что на данный момент у нас нет ни одного коммита. Давайте это исправим. Но прежде всего нам нужно разобраться с тем, как Git работает изнутри.

## Внутреннее устройство Git. Объекты.

Всю информацию Git представляет в виде "объектов". Объект – это файл, содержащий определенную информацию о репозитории и его файлах. Все объекты хранятся в директории .git/objects/. 

Объекты бывают трех типов:

1. Blob (англ. binary large object) – большой бинарный объект, другими словами просто бинарный файл. Для каждого файла в репозитории формируется blob-файл, который содержит его имя и сжатое содержимое. Blob-файл формируется, когда мы добавляем файл в индекс.
2. Tree (англ. tree – дерево). Дерево – это такой тип графа. Оно нужно нам, чтобы показывать связи между файлами в репозитории. Деревья формируются для каждой директории репозитория (в том числе для корневой) во время коммита и показывают, какие файлы (или поддиректории) лежат в данной директории. Таким образом, объект дерева состоит из имен 1) blob-объектов для файлов, которые лежат в данной директории, и 2) других деревьев для всех поддиректорий.
3. Объект коммита. Этот объект содержит в себе имя автора коммита, время коммита и объект дерева корневой директории проекта.


Кроме этих трех объектов, важным во внутреннем устройстве Git является файл индекса.
Индекс – файл, в котором содержатся изменения, подготовленные для добавления в коммит. Во время добавления файлов командой git add, которую мы рассмотрим ниже, Git:

- Сжимает содержимое этого файла и создает blob-объект.
- Записывает имя этого объекта в файл индекса.

![](../imgs/gitobjects.png)

Подытожим
- Git – это большая картотека объектов.
- Git хранит все файлы и связи между ними, как объекты в директории .git/objects.
- Объект – это файл с некоторой информацией о репозитории.
- Объекты бывают трех типов: Blob, Tree и Commit.
- Blob-объекты хранят информацию о файлах репозитория и их содержимом.
- Tree-объекты хранят информацию о расположении этих файлов в репозитории.
- Индекс же нужен Git, чтобы понимать, какие из файлов мы добавим в последующий коммит, а какие – нет.

## Делаем файлы отслеживаемыми. Команда git add

Чтобы сделать файл отслеживаемым, существует команда git add. Разберемся с ней чуть подробнее.

```
Команда git add

Что делает
Добавляет файлы в индекс

Формат
git add <имя файла> <флаги>

Параметры, флаги
-A, --all
С этим флагом под действие команды попадут все файлы в репозитории

Пример
# Добавляем файл dijkstra.c в индекс:
$ git add dijkstra.c

# Добавляем все измененные файлы в индекс:
$ git add -A
# или
$ git add --all
```

Теперь добавим файл alpha.txt в индекс:

```bash
git add alpha.txt
```

Посмотрим на статус файлов теперь:

```bash
$ git status

 
On branch develop

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   alpha.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        num.txt
```

Теперь видно, что мы добавили файл alpha.txt в индекс и Git видит его. Но что же все-таки произошло? Работал Git так:


1. Создал новый blob-объект.

Имя этого файла – SHA-1 хэш – 40-символьная контрольная сумма содержимого и заголовка. Вычисляется он так:
К типу файла (т.е. blob) через пробел дописывается длина содержимого и нулевой байт. В нашем случае для файла alpha.txt, содержащего a мы получим: blob 1\0.
Затем к полученной строке прибавляется само содержимое файла. То есть blob 1\0a.
Затем эта строка отдается хэш-функции SHA-1, которая и выдает нам 40-символьный результат.

Первые два символа полученной суммы определяют имя поддиректории в базе объектов, а остальные 38 – имя файла. Например, хэш файла alpha.txt получился такой:
Хэш файла alpha.txt
ca87a297fe24e72165a6c462b2e1df12a01cbc34
Это значит, что Git создаст директорию .git/objects/ca/ и сохранит в нее blob-файл с именем 87a297fe24e72165a6c462b2e1df12a01cbc34.

![](../imgs/gitblob.png)

Хэширование нужно затем, чтобы однозначно определить файл его содержимым (если содержимое файлов различно хотя бы одним символом, то хэши будут сильно отличаться друг от друга). А разбиение по поддиректориям нужно затем, чтобы потом было проще найти нужный нам файл среди множества других.

Заметьте, что простое добавление файла в Git приводит к сохранению его содержимого в директории objects. Оно будет храниться там, даже если мы удалим alpha.txt из рабочей копии.

2. После сохранения blob-файла, гит добавляет его имя в индекс.

Как было сказано выше, индекс – это список файлов, за которыми следит Git. Он хранится в .git/index. Каждая строчка состоит из имени файла и его хэша. Вот таким получился индекс репозитория, рассмотренного выше:
Содержимое файла .git/index
alpha.txt ca87a297fe24e72165a6c462b2e1df12a01cbc34.

![](../imgs/gitadding.png)

Добавим таким же образом, файл num.txt:

```bash
git add num.txt
```

И посмотрим статус:

```bash
$ git status


On branch develop

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   alpha.txt
        new file:   num.txt
```

Теперь допустим, что мы передумали и решили изменить содержимое файла num.txt c 1 на 1024. Сделаем это и посмотрим статус снова:

```
$ git status


On branch develop

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   alpha.txt
        new file:   num.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   num.txt
```

Видно, что файл num.txt одновременно находится в двух состояниях: подготовленный к коммиту и измененный. Но как такое возможно? Давайте разбираться.

Помните, мы находили хэш-сумму от содержимого файла? Теперь мы это содержимое поменяли и хэш-сумма стала другой. Git это заметил, и предупредил нас. Если мы сейчас сделаем коммит, то в него попадет файл num.txt со значением 1, а не 1024. Чтобы в коммит попали новые изменения, нам нужно заново проиндексировать файл num.txt.

```bash
git add num.txt
```

Можем убедиться, что все хорошо, заново просмотрев статус:

```bash
$ git status


On branch develop

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   alpha.txt
        new file:   num.txt
```

Подведем итог
- Чтобы сделать файл отслеживаемым, существует команда git add.
- Когда мы делаем файл отслеживаемым, происходит следующее: 
- Создается blob-объект для этого файла. Имя blob-объекта – 40-символьный хэш содержимого файла, причем первые две буквы хэша отводятся под имя поддиректории в папке .git/objects, а остальные 38 – под имя самого файла. Такое разделение имени ускоряет поиск blob-файла среди других.
- Имя этого blob-файла записывается в индекс (.git/index). С этого момента GIt считает файл подготовленным к коммиту.
- Если мы поменяем содержимое файла, нам нужно снова добавить его в индекс командой git add.

## Команда git commit. Первый коммит

Итак, как уже было сказано выше, коммит хранит не только снимок (все индексированные файлы) репозитория, но и имя автора со временем, что бывает полезно. Чтобы сделать коммит в Git, есть команда git commit.

```
Команда git commit

Что делает
Создает новый коммит с файлами из индекса.

Формат
git commit <флаги>

Параметры, флаги
-m <описание>
Добавляет к коммиту комментарий. Создать коммит без описания нельзя, но описание можно добавить другими способами (например, из файла). Описывать коммит надо так, чтобы другому человеку было понятно, какие именно изменения вы внесли в данном коммите.

-c <commit>
Берет описание, и информацию об авторе из переданного коммита, когда создает новый. Открывает редактор, давая возможность отредактировать описание коммита.

-С <commit>
То же, что и -с, но не открывает редактор. Берет описание переданного коммита неизменяемым.
Другие флаги

Пример
# Создаем первый коммит с комментарием Add math hometask

$ git commit -m "Add math hometask"

[master 0b1f669] Add math hometask
11 files changed, 7 insertions(+), 638 deletions(-)
rewrite .gitignore (99%)
delete mode 100644 discrete math/hw-3/dm3.pdf
```

В нашем репозитории из прошлого пункта мы уже добавили все файлы в индекс, поэтому нам остается только сделать коммит.

```
$ git commit -m "Initial commit"
[develop (root-commit) 10962e7] Initial commit
 2 files changed, 2 insertions(+)
 create mode 100644 data/alpha.txt
 create mode 100644 data/num.txt
```

Теперь давайте разберемся, что только что произошло и что это за буквы с цифрами 10962e7 в первой строчке вывода.
В целом команда git commit делает три шага:

1. Создает граф (дерево), представляющий содержимое версии проекта, для которой делают коммит.
2. Создает объект коммита.
3. Направляет текущую ветку на новый коммит


Рассмотрим эти шаги по отдельности.

### Создание коммита. Этап 1. Создание графа.

Git представляет текущее состояние проекта, как древовидный граф, информация для которого читается из индекса. Этот граф записывает расположение и содержание файлов в проекте. Граф - это объект-дерево, о котором упоминалось выше. Каждая строчка любого графа записана по следующему правилу:
Формат записи внутри объекта Tree
<режим доступа> <тип объекта> <хэш объекта> <имя файла, из которого создан объект>.

Разберем все по порядку.

Режим доступа это одно из следующих чисел:
1. 100644 – обычный файл.
2. 100755 – исполняемый файл.
3. 120000 – символическая ссылка (напр. HEAD).

Режимы доступа в Git сложно назвать гибкими: указанные три режима – единственные доступные для файлов в Git, хотя существуют и другие режимы, используемые для директорий и подмодулей.
Тип объекта – это строка, которая может принимать значение blob, если объект – это blob-файл, либо tree, если объект – это дерево.
Третье значение – хэш объекта. Это тот самый 40-символьный SHA-1 хэш.
Ну и последнее значение – это имя файла, из которого был создан blob-файл и получен хэш.

Как было сказано выше, граф состоит из двух типов объектов:

Blob-файлы
Tree-файлы, они же деревья.

Первые сохраняются во время выполнения команды git add, вторые – во время выполнения git commit. Для примера рассмотрим репозиторий со следующей структурой:

```
Структура репозитория test_repository
test_repository
└───data
│	└─alpha.txt
│	└─num.txt
└─── outer.txt
```

То есть у нас есть вложенная папка data с файлами alpha.txt, num.txt и отдельный файл outer.txt. Граф директории data, созданный при коммите, будет выглядеть так:

.git/objects/09/d20c0539...
100644 blob ca87a297fe24e72165a6c462b2e1df12a01cbc34    alpha.txt
100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    num.txt

Визуализируя его получим:

![](../imgs/gittree.png)

А дерево для корневой директории репозитория test_repository будет выглядеть следующим образом:
.git/objects/c0/d2cc3e13...
040000 tree 09d20c0539d97b2a60d06db73135cda7dcac4121    data
100644 blob 5ef136008f1e8f921622f7eed1fe1925331c9665    outer.txt

Первая строчка – это дерево директории data/, рассмотренное выше, а вторая – файл outer.txt.

При этом само это дерево, включающее директорию data/ и файл outer.txt будет иметь хэш c0d2cc3e13d34e7043d2afddb4af8867cc972741 (спойлер: оно пригодится для объекта коммита).

Визуализируя граф корневой директории test_repository получим следующее:

![](../imgs/gitcommit.png)

Все эти объекты сохраняются в директорию .git/objects/ по тому же принципу, то есть первые два символа хэша – имя поддиректории в папке .git/objects/, а остальные 38 – имя файла в этой поддиректории.

Подведем итог
- Первым шагом в создании коммита является создание древовидных графов.
- Древовидный граф - это объект типа tree, который хранится в директории .git/objects/.
- Деревья нужны, чтобы отразить взаимное расположение файлов и директорий в репозитории.
- Дерево создается для каждой директории репозитория, в том числе и для корневой.
- Каждая строчка файла дерева устроена по следующей схеме: <режим доступа> <тип объекта> <хэш объекта> <имя файла, из которого создан объект>.


### Создание коммита. Этап 2. Создание объекта коммита

После того, как был создан граф репозитория, Git создает объект коммита. Объект коммита – точно такой же текстовый файл в директории .git/objects/, как деревья и blob-файлы. Объект коммита репозитория из предыдущего примера выглядит так:

```
.git/objects/f9/8b4a7891...
tree c0d2cc3e13d34e7043d2afddb4af8867cc972741
author smartiqa <info@smartiqa.com@email> 1606261256 +0300
committer smartiqa <info@smartiqa.com@email> 1606261256 +0300

Initial commit
```

Первая строчка записи указывает на дерево корня репозитория, то есть тот самый граф (test_repository) с хэшем c0d2cc3…

Вторая строчка говорит, кто и когда создал коммит, третья – кто и когда записал коммит в репозиторий. Обычно эти две строчки совпадают, но бывают и ситуации, когда один человек записывает в свой репозиторий коммит другого человека, тогда эти строчки будут различаться. Тот, кто запишет коммит к себе будет значится в поле committer, а тот, кто создал этот коммит – в поле author.

Ну и в последней, четвертой, строчке содержится комментарий коммита. В нашем случае – Initial commit.

![](../imgs/gitcommit-2.png)

Теперь мы знаем, что коммит – это объект коммита. Хэш этого объекта и есть хэш коммита – уникальный идентификатор, по которому можно найти любой коммит. Обычно хэш не надо писать полностью, достаточно первых 6-8 цифр. Например:

```
$ git commit -m “Initial commit”

[develop (root-commit) f98b4a7] initial commit
 3 files changed, 3 insertions(+)
 create mode 100644 data/alpha.txt
 create mode 100644 data/num.txt
 create mode 100644 outer.txt
```

Здесь f98b4a7 это и есть часть хэша коммита. Git создаст директорию .git/objects/f9 и сохранит в нее объект коммита 8b4a7…, к которому мы потом сможем обращаться.

Подведем итог
- После создания объектов деревьев для всех директорий репозитория, создается объект коммита.
- Объект коммита состоит из:
- 2.1. Объекта дерева корневой директории репозитория
- 2.2. Информации о том, кто и когда создал коммит
- 2.3. Кто и когда записал коммит в историю репозитория
- 2.4. Комментария коммита
- Обычно пункты 2.2 и 2.3 совпадают, но не всегда.
- Имя объекта коммита – его хэш. По этому хэшу можно найти любой коммит. Не обязательно использовать все 40 символов хэша, обычно 6-8 бывает достаточно.

### Создание коммита. Этап 3. Направить ветку на текущий коммит.

В заключение нам нужно сообщить указателю-ветке, что у нас есть новый коммит. Делает это Git следующим образом:

Для начала, нужно посмотреть, на какой ветке мы сейчас работаем (их может быть несколько). Git идет в файл .git/HEAD и видит следующее: ref: refs/heads/develop. Такая запись говорит нам, что HEAD указывает на ветку develop, т. е. ветка, в которой мы сейчас работаем – develop (неудивительно, ведь она единственная).
Напомню, что HEAD и develop – это ссылки, используемые Git или пользователем для указания на определенный коммит.
Затем Git ищет файл .git/refs/heads/develop, но такого файла не существует, поскольку это был первый коммит в нашем репозитории и до сих пор ветке develop было не на что указывать. Поэтому Git создает файл .git/refs/heads/develop и задает его содержимое – хэш объекта-коммита, который мы получили f98b4a7....

Теперь наш граф репозитория выглядит вот так:

![](../imgs/gitcommit-3.png)

## Команда git commit. Делаем второй коммит

Детально разобравшись с процессами создания коммита, изучим граф после первого и второго коммита.

Для примера рассмотрим репозиторий со следующей структурой:

```
Структура репозитория test_repository
test_repository
└───data
       └─alpha.txt
       └─num.txt
```

То есть, как и в предыдущем примере, но без файла outer.txt. Иначе наши графы будут слишком объемными.

Для начала заметим, что наш индекс снова пуст, поскольку все файлы уже добавлены в коммит, а новых изменений нет:

```
git status

On branch develop
nothing to commit, working tree clean
```

Давайте рассмотрим, как выглядит рабочая копия и индекс нашего репозитория на графе.

![](../imgs/Git_working_dir_a.png)

Выглядит запутанно, но постарайтесь разобраться. Рабочая копия и индекс указывают на одни и те же файлы из первого коммита. Это значит, что изменений в файлах нет. Теперь давайте поменяем содержимое файла alpha.txt и посмотрим индекс снова:

```
$ git status

On branch develop
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   data/alpha.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

Снова посмотрим на граф.

![](../imgs/Git_working_dir_a-2.png)

Как видно, теперь в рабочей копии находится измененный файл alpha.txt, но он еще не проиндексирован. Поэтому индекс указывает на первоначальный файл, а вот в рабочей копии находится уже измененный. Давайте проиндексируем его и посмотрим на статус.

```
git add -A
git status

On branch develop
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   data/alpha.txt
```

Вы наверняка догадываетесь, как будет выглядеть граф теперь, но все же приведем схему:

![](../imgs/Git_working_dir_a-3.png)

Теперь рабочая копия указывает на тот же файл, что и индекс, причем этот файл не находится в последнем коммите. Это значит, что у нас есть проиндексированные изменения. Зафиксируем их, то есть сделаем второй коммит.

```
$ git commit -m "change alpha.txt"

[develop 4117d58] change alpha.txt
 1 file changed, 1 insertion(+), 1 deletion(-)
```

Теперь Git создаст новый граф для представления данных из индекса. Старое дерево data/ больше не отражает состояние проиндексированной директории data/ (т.к. файл alpha.txt был изменен), поэтому создается новое. Объект этого дерева(для папки data) выглядит так:

```
Дерево папки data (.git/objects/3b/95bcd6d0...)
100644 blob 7e74e68b2a782a3aead46d987a63ca1c91091c13    alpha.txt
100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672    num.txt
```

Поскольку хэш нового дерева data/ отличается от старого, нужно создать новое дерево для всего репозитория. Объект для корневой директории test_repository будет выглядеть так:

```
Дерево папки test_repository (.git/objects/22/d4301816...)
040000 tree 3b95bcd6d0a76177985b5d3b2fd046b48e9110ba    data
```

И уже только на основе этого дерева можно создавать объект второго коммита.

```
Объект коммита (.git/objects/41/17d584a7...)
tree 22d4301816880a569417c908ee00b2f6680efb33
parent 0790c287b727b43156de737f5840cb6584261830
author smartiqa <info@smartiqa.com> 1606271955 +0300
committer smartiqa <info@smartiqa.com> 1606271955 +0300

change alpha.txt
```

Здесь все, как и в объекте первого коммита, за исключением второй строчки – она новая. Теперь у коммита есть родитель (предок, предшествующий коммит). Чтобы найти родителя, Git проходит в файл .git/refs/heads/develop и смотрит на хэш коммита, который там записан.

После этого Git меняет содержимое .git/refs/heads/develop на хэш текущего коммита. Графически, наш репозиторий теперь выглядит так:

![](../imgs/Git_working_dir_a-4.png)

Заметьте, что мы не меняли num.txt, поэтому Git не стал заново добавлять его в коммит. Вместо этого, в новый коммит вошла ссылка на файл num.txt из прошлого коммита. Такая функция позволяет экономить место и не засорять репозиторий одинаковыми файлами.

##### <a name="Glava_3"> # Глава 3. Ветвление. Создание, переключение и удаление веток. Команды: branch, checkout, status, log, diff.

## Что такое ветка

Дадим два определения ветки: на логическом и физическом уровнях.

1. Логический уровень.
С точки зрения логики, ветка – это последовательность коммитов. Чтобы проще было понять, что такое ветка, рассматривайте ее как некоторую временную шкалу. Коммиты в ней – снимки интересных моментов, идущие друг за другом в хронологической последовательности. Рисунок ниже поможет вам в интуитивном представлении.

![](../imgs/branches.png)

На рисунке выше изображены три ветки: main, develop и feature. Каждая представляет из себя "поток" коммитов в хронологической последовательности. Важно заметить, что эти потоки не пересекаются, то есть работа в ветках идет параллельно.

2. Физический уровень
На физическом уровне, то есть с точки зрения внутренней реализации Git, ветка – это ссылка на последний коммит в этой ветке. Картинка ниже поможет вам понять, что к чему.

![](../imgs/branches-2.png)

Сравнивая рисунки, можно заметить, что ветка-ссылка указывает на коммит, который является последним в "потоке" коммитов в данной ветке. Таким образом, коммит С10 - последний сделанный коммит в ветке main, поэтому указатель main стоит над С10. То же самое можно сказать про develop – для этой ветки последним коммитом является С11, – и про feature, ее последним коммитом будет С7.

```
Немного про указатели
Указатель – это ссылка на определенный коммит или ветку. А ссылка – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит или ветку.
И как мы уже сказали, физически ветки – самые настоящие указатели. Давайте приведем примеры еще некоторых часто используемых указателей:
1. HEAD – так называемый курсор Git. Главное назначение HEAD - определять, в каком состоянии находится рабочая копия (напомним, что рабочая копия – это все файлы репозитория, за исключением директории .git/). На какой коммит указывает HEAD – из того коммита и загружаются файлы в рабочую директорию.
2. ORIG_HEAD – указатель, который появляется, когда мы вручную передвигаем HEAD на какой-нибудь НЕ последний коммит. ORIG_HEAD указывает на тот же коммит, на который указывал HEAD до передвижения назад. Нужен он, чтобы мы имели возможность вернуться на хронологически последний коммит без существенных затрат (в истории мы не будем видеть все коммиты старше нашего, а поэтому не сможем узнать хэш последнего).
3. Пользовательские указатели. Пользователи сами могут создавать указатели. Например, вы можете создать указатель version-1.2.1, который будет указывать на коммит, в котором хранится версия 1.2.1 вашего проекта. Это довольно удобно, поскольку вы можете переключаться на коммит с той или иной версией, не запоминая его хэш.

```

Преимущество веток в их независимости. Вы можете вносить изменения в файлы в одной ветке, например, пробовать новую функцию, и они никак не скажутся на файлах в другой ветке. Изначально в репозитории одна ветка, но позже мы рассмотрим, как создавать другие.
На самом деле, вначале, когда мы делаем свой первый коммит, Git автоматически создает основную ветку. Вы можете помнить, что ее имя по умолчанию "main" мы задавали в настройках Git в предыдущем уроке. Каждый раз, когда мы создаем новый коммит, Git автоматически перемещает указатель main на последний коммит. Тем не менее, в следующем уроке мы узнаем, как перемещать указатель ветки между коммитами самостоятельно.

![](../imgs/branches-3.png)

На рисунке овалы с хэшами – наши коммиты, main – ветка по умолчанию и в то же время указатель на коммит 62aa, а HEAD – указатель на ветку, с которой мы сейчас работаем, то есть на ветку main.

## Зачем нужны ветки

Пока мы разбирались, что такое ветка, у вас мог возникнуть вопрос: зачем нужны такие сложности, ведь можно просто делать коммиты и откатывать изменения, когда нужно.

Дело в том, что Git – универсальная система контроля версий: она подходит и большим командам крупных корпораций, и индивидуальным разработчикам для их личных проектов.

Если вы работаете один – скорее всего вы будете редко использовать ветки, но если вы работаете в большой компании, без веток вам не обойтись.

Итак, чаще всего ветки используются в следующих случаях.

1. Ветки нужны, чтобы несколько программистов могли вести работу над одним и тем же проектом или даже файлом одновременно, при этом не мешая друг другу.
2. Кроме того, ветки используются для тестирования экспериментальных функций: чтобы не повредить основному проекту, создается новая ветка специально для экспериментов. Если эксперимент удался, изменения с экспериментальной ветки переносятся на основную, если нет – новая ветка попросту удаляется, а проект остается нетронутым.
3. Помимо прочего, ветки можно использовать для разных выходящих параллельно релизов одного проекта. Например, в репозитории Python может быть две ветки: python-2 и python-3. До закрытия python-2 релизы этих версий языка выходили независимо друг от друга, поэтому могло иметь место такое разделение на ветки.

На самом деле, у веток есть еще множество применений – все зависит от конкретного проекта, – мы же перечислили только самые распространенные практики их использования. Ветвление в Git – это действительно мощный инструмент, поэтому важно уметь им пользоваться.

## Создание новых веток

Выше мы уже упоминали, что как только вы создаете свой первый коммит, Git создаёт основную ветку, в нашем случае ее имя будет main. Тем не менее, мы можем создавать свои ветки и переключаться между ними. Создать свою ветку можно двумя способами.

### Способ 1. Команды git branch + git checkout

Этот способ является классическим. В нем для начала работы с новой веткой нужно выполнить два действия:
Создать ветку с помощью команды git branch
Переключиться на свежесозданную ветку с помощью команды git checkout <имя ветки>

```
Команда git branch

Что делает
Создает новую ветку.

Формат
git branch <имя ветки>

Пример
# Создадим новую ветку с именем feature
$ git branch feature
```

На самом деле, git branch – очень мощная команда, которая умеет много всего. Сейчас мы рассматриваем ее как инструмент для создания веток. Ниже мы рассмотрим еще некоторые способы ее применения.

И как мы уже сказали, в качестве второго этапа после создания новой ветки, вам нужно переключиться на нее командой git checkout.

### Способ 2. Команда git checkout -b

В основе данного способа лежит тот факт, что команда git checkout умеет создавать ветки и сразу переключаться на них. Это намного удобнее, чем выполнять два этих действия по отдельности. Поэтому данный способ является более предпочтительным, так как задействует только одну команду git checkout со специальным ключом -b .

```
Команда git checkout

Что делает
Создает новую ветку и сразу переключается на нее.

Формат
git checkout <ключ> <имя ветки>

Ключи
-b
Если вы передадите этот ключ, то команда создаст новую ветку, а затем переключится на нее.

Пример
# Создадим ветку 'feature' и сразу же на нее переключимся
$ git checkout -b feature
Switched to a new branch 'feature'
```

Как и git branch, git checkout – очень многофункциональная команда. Главное ее назначение – перемещать указатель HEAD. О том, как она работает и какие еще имеет применения, мы поговорим ниже.

Внутри Git создание ветки работает довольно просто. Выполняются следующие шаги:
1. В директории .git\refs\heads создается новый файл, имя которого – имя ветки, которую вы хотите создать (при условии, что такого файла не существует). Например, если мы выполним команду git branch feature, то создастся файл .git\refs\heads\feature.
2. В созданный файл записывается хэш текущего коммита. С него ветка и начнется. После этого файл .git\refs\heads\feature будет выглядеть так:

```
Содержимое файла .git\refs\heads\feature
971ef6a7e178324b732e2ed6cbc3b66c1c989e15
```

40 шестнадцатеричных цифр в файле выше и есть хэш последнего коммита, на который указывает новосозданная ветка.

Важно понимать, что как только вы создали новую ветку, она указывает на тот же коммит, что и основная ветка, и HEAD. Графически ситуация выглядит так:

![](../imgs/branches-4.png)

Как видно из картинки, сейчас HEAD указывает на основную ветку (коммит 62aa). Если же вы переключитесь на ветку feature и сделаете два новых коммита (4b00 и 6670), ситуация будет выглядеть так:

![](../imgs/branches-5.png)

Как мы видим, указатели feature и HEAD передвинулись на последний коммит 6670.

С помощью команд git branch и git checkout вы можете создать неограниченное количество веток и переключаться между ними по мере необходимости. Обычно если ветка вам больше не нужна, ее сливают с основной и удаляют. Тема слияния веток заслуживает отдельного урока, поэтому про это мы поговорим в следующий раз, а удаление веток рассмотрим чуть ниже.

## Просмотр списка веток

Когда вы работаете с большим количеством веток, можно легко забыть имя нужной, а без имени ветки переключится на нее не получится. Для таких ситуаций существует команда просмотра списка веток. На самом деле, это уже знакомая нам git branch, но с другими ключами.

```
Команда git branch

Что делает
По умолчанию выводит список локальных веток. С ключами -r, -a можно вывести, соответственно, либо только удаленные ветки, либо все ветки.

Формат
git branch <ключи>

Ключи
-r
От англ. remote – удаленный. С этим ключом будут выведены только удаленные ветки. О них мы поговорим в следующем уроке.
-a
От англ. all – все. С этим ключом будут выведены и локальные, и удаленные ветки.

Пример
# Выведем локальные и удаленные ветки
$ git branch -a
* develop
feature
main
remotes/origin/HEAD -> origin/main
remotes/origin/develop
remotes/origin/feature
remotes/origin/main

# Теперь выведем только локальные ветки
$ git branch
* develop
feature
main

# А теперь только удаленные ветки
$ git branch -r
origin/HEAD -> origin/main
origin/develop
origin/feature
origin/main
```

В примере выше можно увидеть, что перед веткой develop стоит звездочка. Такая запись означает, что сейчас указатель HEAD находится на ветке develop. Аналогично строка origin/HEAD -> origin/main означает, что указатель HEAD удаленного репозитория находится на удаленной ветке main.

Теперь, когда мы поняли, как можно узнать имена веток в репозитории, давайте научимся переключаться между ними.

## Переключение между ветками

Итак, настало время подробнее разобраться с тем, как переключаться между ветками. Как уже было сказано выше, чтобы переключиться на ветку, вам нужно знать ее имя. Напомним, что просмотреть список всех веток можно с помощью команды git branch. Просмотрим список веток в некотором репозитории:

```
$ git branch
  develop
  main
* feature
```

Как мы уже знаем, звездочка перед веткой означает, что сейчас мы находимся на данной ветке (в нашем случае это ветка feature). Если мы хотим переключиться на другую, нам нужна уже знакомая команда git checkout.

```
Команда git checkout

Что делает
Переключает пользователя на другую ветку

Формат
git checkout <ключи> <имя ветки>

Пример
# Переключимся на ветку develop
$ git checkout develop
Switched to branch 'develop'
```

Кстати, вместо имени ветки, можно писать -, чтобы переключиться на предыдущую ветку, например:

```
# Выведем список локальных веток
$ git branch
  develop
  feature
* main

# Переключимся на ветку develop
$ git checkout develop
Switched to branch 'develop’

# Переключимся на ветку feature
$ git checkout feature
Switched to branch ‘feature’

# Вернемся на ветку develop
$ git checkout -
Switched to branch 'develop'
```

Этот маленький фокус позволит вам сэкономить время, особенно, если вы часто переключаетесь между ветками.

### Теперь приведем список действий, которые производит git checkout, чтобы переключить нас на новую ветку:

1. Программа проверяет, существует ли указанная ветка.
2. Затем программа переключает указатель HEAD на новую ветку.
3. Последним шагом программа меняет рабочую копию так, чтобы она соответствовала новой ветке.

Поначалу кажется, что система замысловата, но на самом деле она очень проста. Давайте разбираться с каждым шагом по отдельности.

### Шаг 1. Проверка существования ветки
Нужен этот этап, чтобы случайно не переключиться на ветку, которой не существует. Чтобы понять, как происходит этот процесс, нужно сделать небольшое отступление и рассказать, как вообще Git хранит информацию о существующих ветках.

Итак, мы помним, что ветка – это тоже указатель, как и HEAD. Она указывает на последний коммит в "потоке" коммитов ветви графа Git. Графически это выглядит так:

![](../imgs/branches-6.png)

Как видно из рисунка, у нас есть две ветки: main и feature. HEAD сейчас указывает на main, поэтому сейчас рабочая копия репозитория находится в состоянии коммита 5с5с.

Все, что нужно, чтобы задать ветку – просто записать, на какой коммит она указывает. Этого достаточно, поскольку по предкам этого коммита можно восстановить весь остальной граф. Поэтому внутри Git ветка – это просто файл в директории .git\refs\heads, названный так же, как и сама ветка. Например, в случае репозитория, граф которого изображен на картинке выше, мы получим:

```
Директория .git\refs\heads
main
feature
Содержимое файла main
5с5с…
Содержимое файла feature
6670…
```

Таким образом, если файл с именем ветки присутствует в директории .git\refs\heads, можно однозначно сказать, что такая ветка существует.

### Шаг 2. Переключение HEAD на нужную ветку

Теперь, когда Git убедился, что ветка с нужным именем существует, необходимо как-то переключить указатель HEAD на эту самую ветку. То есть сделать так, чтобы HEAD указывал на файл ветки. Делается это очень просто: нужно в файл .git\HEAD записать путь до нужной нам ветки: refs\heads\<имя ветки>. Тогда HEAD будет указывать на новую ветку.

В нашем случае, при переключении на ветку feature, файл .git/HEAD будет выглядеть так:

```
Содержимое файла .git\HEAD
refs\heads\feature
```

После этого шага граф Git будет выглядеть следующим образом:

![](../imgs/branches-7.png)

Как видно, HEAD теперь указывает на ветку-указатель feature. Картинка поменялась, поскольку мы записали в файл .git\HEAD новый адрес. В данном случае, это refs\heads\feature. Таким образом, до полного переключения на другую ветку остался всего один шаг.

### Шаг 3. Изменение рабочей копии

Рабочие копии на разных ветках могут отличаться, поскольку ветки работают независимо друг от друга. Поэтому последним шагом при переключении на новую ветку станет изменение рабочей копии так, чтобы она соответствовала нашей ветке. Git просто смотрит на последний сделанный в данной ветке коммит, после чего восстанавливает структуру и файлы в рабочей копии, подгружая данные из blob- и tree- объектов, о которых мы говорили в прошлом уроке. То есть Git будет действовать так:

- Любой файл, который есть в новом коммите (6670) на рисунке выше и которого нет в коммите, с которого мы переключились (5с5с), будет добавлен в рабочую копию.
- Любой файл, который был в коммите, с которого мы переключились (5с5с), и которого нет в новом коммите (6670), будет удален.
- Любой файл, которого нет ни в одном из этих двух коммитов, будет просто проигнорирован. То есть удален он НЕ будет.


Как только все три эти условия выполняются для всех файлов в рабочей копии, можно говорить о том, что Git полностью переключил нас на нужную ветку.

У внимательного читателя мог возникнуть вопрос: почему файлы в рабочей копии подгружаются именно из последнего коммита ветки? Что если до переключения с данной ветки, в ней были какие-то изменения, еще не добавленные в коммит? Что с ними будет? Ответ довольно прост. Согласно трем шагам, указанным выше, Git просто проигнорирует все такие файлы. То есть они останутся в вашей рабочей копии в том же состоянии, в котором и были до этого. Как правило, такое поведение очень неудобно, поскольку позволяет легко запутаться в структуре собственного проекта. Представьте: у вас два параллельных релиза, а вы, переключаясь между ветками, случайно занесли файлы одного релиза в ветку другого.

Таким образом, у вас есть два варианта выхода из ситуации:

1. Либо добавить все изменения в коммит и благополучно сменить ветку
2. Либо "отложить" изменения, не добавляя их в коммит, воспользовавшись командой git stash.

```
В двух словах о git stash
Говоря кратко, git stash прячет ваши изменения в некоторый внутренний стек Git. Чтобы "отложить" изменения, достаточно ввести команду git stash. На самом деле, каждое применение git stash создает отдельный коммит, хэш которого записывается в стек. Поэтому с помощью этой команды можно неограниченное количество раз откладывать изменения. Просмотреть список всех отложенных изменений можно командой git stash list. Чтобы достать изменения из стека и вернуть их в рабочую копию, нужно использовать команду git stash pop. Таким образом, вы можете откладывать ваши изменения перед переходом на новую ветку, а затем доставать их обратно.
```

Забегая вперед, скажем, что git checkout используется не только для перемещения указателя HEAD между ветками. Вы точно также можете перемещать этот указатель по коммитам одной и той же ветки. Это может быть нужно, если вы, например, заметили, что допустили ошибку в пояснении к старому коммиту. Вы можете просто переместить указатель HEAD на нужный коммит, и исправить сообщение. Эту технологию мы разберем в следующем уроке, а сейчас вернемся к более практичным вещам. Давайте поговорим про состояния файлов ветки и историю коммитов.

## Просмотр состояния ветки. Команды: git status, git log, git diff.

Как уже не раз было сказано выше, главное преимущество веток заключается в их независимости. Благодаря этому свойству, вы можете создать файл в рамках одной ветки, и это никак не повлияет на состояние другой. Поэтому некоторые команды работают для каждой ветки отдельно. Давайте разберем подробнее эти команды с учетом наших знаний о ветках.

### Просмотр состояния файлов ветки. Команда git status.

Чтобы просмотреть состояния файлов конкретной ветки нужно выполнить последовательность из двух команд:

1. git checkout <имя ветки> # переключаемся на нужную ветку
2. git status # просматриваем статус файлов ветки

Выше мы говорили, что файлы, не добавленные в коммит одной ветки, будут перенесены на другую при переключении на нее. Пример такой ситуации можно увидеть ниже.

```
# Просмотрим список доступных веток. Сейчас мы внутри ветки feature.
$ git branch
  develop
* feature
  main

# Просмотрим cостояние файлов в этой ветке
$ git status
On branch feature
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        new_file.txt

# Как видно, у нас есть один неотслеживаемый файл “new_file.txt”. Попробуем переключиться на другую ветку, например, develop.
$ git checkout develop
Switched to branch develop

# Теперь просмотрим статус файлов этой ветки.
$ git status
On branch develop
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        new_file.txt

# Видим, что наш файл  “new_file.txt” последовал за нами в новую ветку. Давайте сделаем коммит и проверим, остался ли этот файл в ветке feature.
$ git add -A
$ git commit -m "agging new_file.txt"
[develop 7b8f2ff] agging new_file.txt
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 new_file.txt

# Проверим, что измененных файлов не осталось
$ git status
On branch develop
nothing to commit, working tree clean

# Переключимся обратно на ветку feature и проверим, остался ли там этот файл.
$ git checkout -
Switched to branch 'feature'

$ git status
On branch feature
nothing to commit, working tree clean

# Как видно – нет.
Пример выше показывает, что нужно быть очень осторожным, переключая ветки. В идеальном случае до и сразу после переключения ветки вывод git status должен быть "пустым", то есть говорить о том, что измененных файлов нет. Если вы не уверены, что закоммитили все изменения, лучше лишний раз убедитесь в этом, прописав git status. Это спасет вас от многих проблем, вызванных "перетаскиванием" файла не на ту ветку.
```

### Просмотр истории коммитов ветки. Команда git log.

В работе программиста часто бывает нужно просмотреть историю коммитов:
- либо чтобы узнать, кто внес те или иные изменения,
- либо чтобы вспомнить хэш коммита, к которому хочется откатиться,
- либо просто проследить за историей развития проекта.

Просмотреть историю коммитов нам поможет команда git log:

```
Команда git log

Что делает
В различных форматах выводит историю коммитов. В различных ситуациях это может быть либо полная история всех коммитов, либо история нескольких из них.

Формат
git log <ключи> --<путь>

Ключи
-<число>, -n <число>
Вывести только последние несколько коммитов. Их число вы указываете в параметре к этому ключу.

--pretty=<значение>
Красивый вывод истории. Доступные значения: oneline, short, medium, full и др.

-p
Показывает изменения, сделанные в данном коммите.

--graph
Рисует ASCII-граф взаимосвязи коммитов.

--all
Выводит историю всех имеющихся коммитов на всех ветках.

Пример
# Выведем последние 7 коммитов, воспользовавшись "красивым" выводом в одну строку.
$ git log -7 --pretty=oneline
8bb113c62cffdd3cada27b4179410f110f6f1321 (HEAD -> develop, origin/develop) adding complex algebra project
603def20e5da2d512da2852011eb5be3fa156940 (origin/main, origin/HEAD) eng. hometask done
86f24ac203c9a1a609e4f303e5c896746b13a054 minor changes and files movements
0b1f66921a08d42122e0f69babd912a2cc01ec82 minor changes
8f0479b6676b7e38eb0dd409690845bd9a64f19d new hometasks were done
cb3395bb21a353ea4ee885c4d493690e3c6294cb adding code docs
0117d8a38ed557c95a7f2959c89c1f3107a1d614 discrete math hometask done

# Выведем последние 2 коммита с обычным оформлением.
$ git log -2
commit 8bb113c62cffdd3cada27b4179410f110f6f1321 (HEAD -> develop, origin/develop)
Author: smartiqa <info@smartiqa.ru>
Date: Thu Feb 11 02:04:24 2021 +0300

adding complex algebra project

commit 603def20e5da2d512da2852011eb5be3fa156940 (origin/main, origin/HEAD)
Author: smartiqa <info@smartiqa.ru>
Date: Fri Dec 4 02:00:41 2020 +0300
```

В описании команды git log выше сказано, что в зависимости от ситуации, она может вывести полную историю репозитория, или же только историю некоторых коммитов. Давайте разбираться, как работает Git при выводе истории.

Общее правило, которым руководствуется Git при выводе истории, такое: иди по предкам коммитов, пока они не закончатся. Иногда это бывает удобно, иногда – нет.

Давайте разберемся, что делать, если мы хотим просмотреть историю коммитов только внутри какой-то конкретной ветки. То есть историю от момента создания ветки, до последнего коммита в ней. В этом случае нужно сделать следующее:

1. Переключиться на ветку, историю коммитов которой мы хотим просмотреть.
2. Выполнить команду git log <ключи> <имя родителя текущей ветки>..<имя текущей ветки>.

Например:

```
# Выведем список локальных веток
$ git branch
  develop
  feature
* main

# Переключимся на ветку feature
$ git checkout feature
Switched to branch ‘feature’

# Просмотрим историю только для ветки feature
$ git log --pretty=oneline develop..feature
b5d154854d794f90eca6426c1a0ae1f8d9696251 (HEAD -> feature) adding new feature
```

Давайте разбираться, откуда взялся такой сложный вызов. Дело в том, что в качестве пути к коммитам, историю которых мы хотим просмотреть, мы можем передать два указателя через две точки: <указатель-1>..<указатель-2>. Тогда git log выведет все коммиты после указателя-1 и до указателя-2. Это, кажется, нетрудно. Но почему в качестве указателей мы передаем родителя текущей ветки и ее саму? Чтобы понять, давайте взглянем на граф Git.

![](../imgs/branches-8.png)

Если мы попытаемся просмотреть лог ветки main, то все будет хорошо: Git просто пойдет по предкам коммитов в обратном порядке и выведет: C5, C3, C2, C1. Но если мы попробуем просмотреть лог ветки feature, то получим: C6, C4, C3, C2, C1, что может нас запутать: после вывода всех коммитов ветки feature, Git начал выводить коммиты ветки main до ответвления feature.

Получается, что если мы хотим получить коммиты исключительно ветки feature, то нам нужно указать, что Git должен остановиться, как только дойдет до коммита, младше указателя ветки main. То есть младше указателя ветки-родителя. Таким образом, мы передаем Git инструкцию: выведи все коммиты старше main и младше feature. Давайте пошагово разберем, как работает Git:
Идем в обратном порядке. С6 младше feature? Да. C6 Старше main? Да, поскольку это другая ветка. Выводим C6.
C4 младше feature? Да. C4 Старше main? Да, выводим C4.
C3 младше feature? Да. C3 Старше main? Нет, поскольку, main указывает на C5, который является наследником С3. Таким образом С3 младше main. Останавливаемся.

Такой алгоритм работает всегда: как только ветка, историю с которой мы выводим, присоединяется к своему родителю, срабатывает наше условие и вывод останавливается. Очевидно, что для самой основной ветки таких условий не требуется, ведь она первоначальная.

В любом случае, если вам сложно визуально представить свой репозиторий, просто воспользуйтесь командой git log --all --graph. С ней вы увидите, как выглядит граф вашего репозитория и поймете, что нужно делать, чтобы получить историю той или иной ветки.

### Просмотр различий между коммитами. Команда git diff.

Бывает необходимо просмотреть различия между двумя коммитами. Так вы сможете понять, какие конкретно изменения были внесены вместе с данным коммитом. Для реализации такой возможности в Git существует команда git diff.

```
Команда git diff

Что делает
Помогает просмотреть изменения между файлами, коммитами, ветками.

Формат
git diff <ключи> <путь до файла> <путь до файла>

Ключи
--diff-filter=<метка>
Позволяет выбирать, изменения между какими файлами показывать. Возможные значения метки: A (от англ. to add – добавить) – файлы, добавленные в индекс, D (от англ. to delete – удалить) – удаленные файлы, M (от англ. to modify – изменить) – файлы, в которые были внесены изменения с момента последнего коммита, и некоторые другие.

--word-diff=color
Подсвечивает добавленные слова зеленым цветом, а удаленные – красным. По умолчанию словом считается неразрывная последовательность символов между пробелами.

Пример
# Посмотрим различия между двумя последними коммитами. Чтобы это сделать, узнаем хэши этих коммитов с помощью git log.
$ git log -2 --pretty=oneline
89577eee09f17cafd7bcf8ba55d0cc6cbd293bbb (HEAD -> develop) changed doc-for-diff
f0c9083f4a4b989b978d88599741de5653e4746e added doc-for-diff

# Зная коммиты, просмотрим изменения. Можно заметить, что необязательно полностью вводить хэш коммита, достаточно первых 5-6 символов.
$ git diff c23ad02 3c5d306
diff --git a/doc-for-diff.txt b/doc-for-diff.txt
index 683de51..33a584a 100644
--- a/doc-for-diff.txt
+++ b/doc-for-diff.txt
@@ -1 +1,2 @@
Здесь есть какие-то строки текста или кода
+А вот тут мы добавили одну строку
```

Чтобы понять, как читать вывод git diff, рассмотрим еще один пример. Допустим, есть репозиторий с файлом doc-for-diff.txt. Изначально файл выглядел так:

```
Содержимое файла "doc-for-diff.txt" до изменения:
Строка 1 (будет удалена)
Строка 2 (не меняется)
```

А после изменений стал выглядеть так:

```
Содержимое файла "doc-for-diff.txt" после изменения:
Строка 3 (заменила Строку 1)
Строка 2 (не меняется)
```

![](../imgs/branches-9.png)

Рассмотрим, как будет выглядеть вывод git diff для этих двух файлов:

```
$ git diff ee05baa b88dc11
diff --git a/doc-for-diff.txt b/doc-for-diff.txt
index e044913..c1fe177 100644
--- a/doc-for-diff.txt
+++ b/doc-for-diff.txt
@@ -1,2 +1,2 @@
-Строка 1 (будет удалена)
+Строка 3 (заменила Строку 1)
 Строка 2 (не меняется)
```

Давайте построчно разберемся, что значит этот странный вывод.

1. Первая строка вывода diff --git a/doc-for-diff.txt b/doc-for-diff.txt – это данные сравнения. В данном случае сравниваются два файла: a/doc-for-diff.txt из первого коммита, и b/doc-for-diff.txt из второго.
2. Затем идут метаданные сравнения, в нашем случае: index e044913..c1fe177 100644. В данном случае это часть хэша blob-объекта для файла a/doc-for-diff.txt.
3. Третья и четвертая строки заключают в себе легенду последующего вывода. в нашем случае она выглядит так: --- a/doc-for-diff.txt +++ b/doc-for-diff.txt. Такая запись означает, что изменения из файла a/doc-for-diff.txt помечаются знаком -, а изменения из файла b/doc-for-diff.txt помечаются знаком +.
4. После легенды начинаются блоки сравнений. Именно блоки, поскольку общие фрагменты двух файлов игнорируются. Каждый блок затрагивает несколько строк сравнения и начинается с заголовка.
5. Первая строка блока называется заголовок. Она заключена между знаками @@. В заголовке описано, какие изменения были внесены в файл. В нашем случае заголовок сообщает, что, начиная с 1 строки, было удалено 2 строчки и вместе с тем, начиная с 1 строки, было добавлено 2 строчки. Может возникнуть вопрос: почему 2, если мы поменяли всего одну строку? Дело в том, что Git считает длину блока. В нашем случае, в блоке две строки. Для простоты можно считать, что неизмененные строки удалили, а на их место добавили точно такие же. Если бы неизмененных строк было много, Git пропустил бы их и разбил изменения на несколько блоков. В нашем же случае всего одна строка не изменилась, поэтому Git не стал так делать.
6. Последующие строки это непосредственно сами изменения. В нашем случае по данному выводу можно сказать, что УДАЛЕННАЯ часть файла a/doc-for-diff.txt выглядела так:


```
Удаленное содержимое файла "a/doc-for-diff.txt"
Строка 1 (будет удалена)
```

А ДОБАВЛЕННЫЕ в файл b/doc-for-diff.txt строки, это:

```
Добавленное содержимое файла "b/doc-for-diff.txt"
Строка 3 (заменила Строку 1)
```

Но такой вывод бывает не всегда. Иногда файл оказывается бинарным, тогда нет смысла выводить информацию о удаленных и добавленных в файл строках. Поэтому git diff выводит различную метаинформацию о нем. Например, хэш-сумму и размер вот так:

```
$ git diff fc99663ca20e98012b5a1fb0 abd1282acb623fd8729a6e7
diff --git a/gpt2-generator/gpt2-memes-params.zip b/gpt2-generator/gpt2-memes-pa
rams.zip
new file mode 100644
index 0000000..e0ad67c
--- /dev/null
+++ b/gpt2-generator/gpt2-memes-params.zip
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:8f32b36ff1f19f93a6d00a2523a7ed629aea2cae108ce359e3cbc3bcc214881b
+size 462580017
```

Теперь вы знаете, как доставать полезную информацию из истории изменений и различий между файлами.

Подведем итог:
1. Будьте осторожны переключаясь между ветками. Не "утащите" файл с одной ветки на другую. Перед и сразу после переключения между ветками, вывод git status должен быть пустым.
2. Чтобы просмотреть историю изменений, используйте git log. Ключ --pretty=oneline позволит сделать вывод лаконичным, а с помощью ключа -n=<число> можно указать количество необходимых коммитов. Если запутались в репозитории, постройте граф с ключом --graph, это поможет разобраться, что к чему.
3. Чтобы просмотреть различия между коммитами, стоит использовать git diff. Эта команда выведет краткую информацию о внесенных изменениях и построчный анализ внесенных изменений.


## Удаление веток

Большинство веток в ваших репозиториях, скорее всего, будут короткоживущими: создали ветку, протестировали новую функцию, слили ветку с основной и удалили ее. О процессе слияния веток мы поговорим в следующий раз, а пока давайте узнаем, как удалять ветки.

Как и всегда, когда речь доходит до удаления чего-либо, нужно быть очень осторожным. Когда вы удаляете ветку, все изменения, которые не были добавлены в коммит, будут утеряны. Делаем акцент: не добавленные в коммит, поскольку даже после удаления ветки вы сможете поместить указатель HEAD на тот коммит, на который указывала удаленная ветка (при условии, что вы помните часть хэша этого коммита), в этом случае вы попадете в состояние detached head, но об этом в следующий раз. В любом случае, будьте очень внимательны, удаляя ветки.

Итак, для удаления мы воспользуемся уже знакомой командой git branch с ключами -d и -D.

```
Команда git branch

Что делает
Удаляет указанную ветку.

Формат
git branch <ключ> <имя ветки>

Ключи
-d
--delete
С этим ключем команда удалит вашу ветку. Ветка будет удалена только в том случае, если она полностью слита с одной из других веток. В противном случае, Git выдаст предупреждение, о том, что в ветке есть неслитые изменения, и не даст ее удалить.

-D
Этот ключ нужен, если вы хотите удалить ветку, игнорируя предупреждения Git. В отличие от -d, этот ключ удалит ветку в любом случае, даже если в ней есть изменения, которые вы можете потерять.

Пример
# Выведем список локальных веток
$ git branch
* develop
feature
main

# Попробуем удалить ветку feature
$ git branch -d feature
error: The branch 'feature' is not fully merged.
If you are sure you want to delete it, run 'git branch -D feature'.

# Получаем предупреждение Git, о котором говорилось выше. Воспользуется ключом -D.
$ git branch -D feature
Deleted branch feature(was cc8005b).

# Как видно, ветка была удалена, а Git вывел нам хэш коммита, на который указывала удаленная ветка.
```

На удивление, здесь нет никаких тонкостей, о которых стоило бы упомянуть, поэтому теперь вы можете смело заявить, что умеете удалять ветки.

## ОБЩИЙ ИТОГ

Итак, вспомним, чему мы научились в этом уроке.
1. Мы узнали, что ветка это тоже указатель, и научились интуитивно представлять себе ветки.
2. Узнали, что ветки нужны для распараллеливания работы над проектом и тестирования новых функций.
3. Мы научились создавать ветки. Можно использовать git branch <имя ветки>, но удобнее git checkout -b <имя ветки>, поскольку такая команда сразу переключит нас на новую ветку.
4. Научились просматривать список веток с помощью команды git branch.
5. Узнали, как переключаться между ветками, используя команду git checkout, и про то, что можно случайно перенести файл с одной ветки в другую.
6. Научились просматривать статус файлов в ветке.
7. Познакомились с командой git log, научились выводить историю одной ветки и строить граф репозитория.
8. Узнали, как просмотреть различия между двумя коммитами или файлами.
9. Научились удалять ветки.

##### <a name="Glava_4"> # Глава 4. Перемещение курсора и отмена изменений. Команды git restore, git rm, git reset, git checkout, git commit, git revert.

Сегодня мы познакомимся с командами, которые позволят удалять и восстанавливать файлы в рабочей копии и индексе, отменять изменения на уровне целых коммитов, возвращаться в прошлое нашего репозитория и манипулировать указателем HEAD.

## Удаляем и восстанавливаем файлы правильно. Команды git rm и git restore.

Начнем с удаления файлов. У читателя может возникнуть вопрос: почему нельзя просто взять и переместить файл из репозитория в корзину, как мы привыкли это делать с обычными файлами? Давайте разбираться.

Как мы говорили во втором уроке, файл в репозитории может находится в нескольких состояниях:

1. Отслеживаемый.
Измененный (неподготовленный к коммиту).
Подготовленный к коммиту.
2. Неотслеживаемый.

Когда мы делаем файл отслеживаемым или подготавливаем его к коммиту, информация об этом файле записывается в индекс (файл .git/index). Эта информация никуда не денется, даже если мы удалили файл из рабочей копии. Рассмотрим пример. Допустим, мы выполним следующие действия:

1. Создадим файл sample.txt и внесем в него какие-то изменения;
2. Сделаем его отслеживаемым;
3. Удалим файл sample.txt;
4. Сделаем коммит;

В таком случае, просматривая содержимое нового коммита, мы обнаружим, что файл sample.txt в нем присутствует, несмотря на то, что мы вроде бы его удалили. Это произошло из-за того, что хоть мы и удалили файл из рабочей копии, но не удалили информацию о нем из индекса.

В Git существует специальная команда, чтобы удалять файлы "правильно".

```
Команда git rm

Что делает
Удаляет файл из рабочей копии и индекса / только из индекса. Данная команда не может удалить файл только из рабочей копии.

Ключи
-f, --forced
Форсированное удаление. Файл будет удален, несмотря на все предупреждения. Используйте этот ключ осторожно.

--cached
С этим ключом команда очистит только информацию о файле в индексе. Сам файл в рабочей копии останется нетронутым, независимо от того, изменен он или нет. При этом файл из области "подготовленный к коммиту" (англ. staged) пе

Пример
# Удалим файл sample.txt из рабочей копии и индекса
$ git rm sample.txt

# Удалим файл sample.txt из индекса и перемеcтим его в категорию Untracked
$ git rm --cached sample.txt
```

Внимательный читатель спросит: но почему нельзя удалить файл из репозитория обычным образом, а затем добавить изменения в индекс командой git add и сделать коммит? На самом деле можно. Команда git rm является сокращением вышеописанных действий. Ее применение считается более правильным, поскольку она короче и красивее. Давайте рассмотрим небольшой пример:

```
# Удалим файл обычным образом
$ rm sample.txt
$ git status
On branch main
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        deleted:    sample.txt
$ git add -A

# И вся последовательность команд выше эквивалентна всего одной:
$ git rm sample.txt
rm 'sample.txt'

$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    sample.txt

# Осталось только сделать коммит, чтобы сохранить изменения:
$ git commit -m "L-04: Deleted sample.txt"
[main f34705a] L-04: Deleted sample.txt
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 sample.txt
```

![](../imgs/gitrm.png)

![](../imgs/gitrm-2.png)

Итак, мы разобрались с удалением файлов. Но что, если мы захотим восстановить файл после удаления или изменения в рабочей копии или индексе? Для этого существует команда git restore. Давайте разберем ее подробнее.

```
Команда git restore

Что делает
Восстанавливает указанный файл из переданного источника. По умолчанию источником является индекс. Если файла нет в указанном источнике, файл будет удален.

Формат
git restore <ключ> <имя файла>

Ключи
-s, --source=<tree>
Этот ключ нужен, чтобы передать команде путь к коммиту (ветке, пользовательскому указателю), откуда мы будем восстанавливать файл. По умолчанию файл берется из области индекса.

--worktree (англ. рабочая копия)
--staged (англ. область индекса)

Эти два ключа позволяют указать, где именно восстанавливать файл. По умолчанию, если ни один из этих двух ключей не передан, файл восстанавливается только в рабочей копии.

Если же передан ключ --staged, файл восстанавливается только в области индекса. В этом случае источником восстановления по умолчанию является коммит, на который указывает HEAD (поскольку мы не можем восстановить файл в области индекса из самой же области индекса).

Если же вы хотите восстановить файл и в рабочей копии, и в области индекса, вам нужно передать оба ключа.

Пример
# Если вы случайно удалили файл sample.txt обычным способом, то можно восстановить его из индекса
$ git restore sample.txt

# Вернем файл sample.txt к определенному коммиту с хэшем 09c2240. При этом мы изменим только файл в рабочей копии, файл в области индекса не поменяется.
$ git restore --source 09c2240 sample.txt

# Вернем файл sample.txt в индексе к состоянию последнего коммита (отменим все внесенные изменения или удалим файл, если в предыдущем коммите его не было), при этом изменения коснутся только индекса файла, рабочая копия не поменяется.
$ git restore --staged sample.txt

# Сделаем то же, что и в предыдущем примере, но теперь изменения затронут и файл в рабочей копии.
$ git restore --staged --worktree sample.txt
```

С помощью команды git restore можно сделать неотслеживаемыми файлы, которые вы случайно добавили командой git add. Приведем пример:

```
# Допустим у нас есть некоторый репозиторий, просмотрим статус файлов:
$ git status
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
       file_to_commit.txt
       another_file_to_commit.txt
       file_not_for_commit.txt

# Для простоты добавим все файлы в индекс разом
$ git add -A

$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   file_to_commit.txt
        new file:   another_file_to_commit.txt
        new file:   file_not_for_commit.txt

# А теперь восстановим файл “file_not_for_commit.txt” в области индекса. Тогда источником станет последний коммит, а в нем такого файла нет (файл же новый). Поэтому файл будет удален из области индекса. Кстати, можно заметить, что даже Git подсказывает нам: “use "git restore --staged <file>..." to unstage”. 

$ git restore --staged file_not_for_commit.txt

$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   another_file_to_commit.txt
        new file:   file_to_commit.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file_not_for_commit.txt

# Для справки: в данном случае эквивалентной командой будет:
$ git rm --cached file_not_for_commit.txt
rm 'file_not_for_commit.txt'

$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   another_file_to_commit.txt
        new file:   file_to_commit.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        file_not_for_commit.txt
```

Подведем итог

Итак, мы теперь умеем удалять и восстанавливать файлы из индекса и рабочей копии.
1. Чтобы удалить файл правильно, воспользуйтесь командой git rm. Она удалит файл из индекса и из рабочей копии.
- Вариант git rm --cached удалит файл из индекса и переместит его в категорию Untracked.
- По своей сути git rm <filename> представляет сокращение двух команд: rm <filename> и git add <filename>.
2. Чтобы восстановить файл в рабочей копии и/или индексе, воспользуйтесь командой git restore.
- Ключ --source=<tree> позволит вам указать место, откуда брать файл для восстановления. По умолчанию этим местом является область индекса.
- По умолчанию файл восстанавливается в рабочей копии, но вы можете восстановить файл в области индекса с ключом --staged или одновременно в области индекса и в рабочей копии, передав ключи --staged --worktree. В этом случае по умолчанию (если вы не передали ключ --source) файл будет взят из коммита, на который указывает HEAD.

## Просмотр старых коммитов и перемещение указателя HEAD

Итак, пришло время разобраться, каким образом можно перемещать HEAD (и другие указатели тоже) и что это дает. Для начала нужно прояснить несколько важных аспектов, которые мы уже упоминали, но не обращали ваше внимание на них:

1. Весь репозиторий – это древовидный граф, ноды которого – наши коммиты, а ребра – родительские отношения между коммитами.
2. HEAD – это указатель (то есть ссылка на один из коммитов), главное назначение которого - определять, в каком состоянии находится рабочая копия. На какой коммит указывает HEAD – в таком состоянии файлы и находятся в рабочей области.
3. Обычно HEAD указывает не на определенный коммит, а на указатель ветки, который в свою очередь указывает на конкретный коммит.
4. HEAD можно перемещать: при перемещении указателя файлы в рабочей копии изменятся так, чтобы соответствовать коммиту, на который указывает HEAD.
5. Указывая путь до чего бы то ни было, вы можете использовать как абсолютные указатели, например, хэш коммита или имя ветки, так и относительные. Вспомним, как пользоваться относительными указателями:
- Знак ^ означает "предыдущий". Например путь HEAD^ означает "предыдущий коммит перед тем, на который указывает HEAD"
- Знак ~ позволяет вам указать число коммитов. Например, запись HEAD~7 означает "7 коммитов назад от коммита, на который указывает HEAD".

Использование относительных путей особенно удобно, поскольку они позволяют не запоминать хэши коммитов и не обращаться к истории репозитория чаще, чем это действительно нужно.

Давайте подробнее разберемся с перемещением указателя, а затем поговорим, зачем это может быть нужно. Итак, чтобы перемещать указатель, нужно воспользоваться знакомой нам из прошлого урока командой git checkout.

```
Команда git checkout

Что делает
Переводит курсор HEAD на указанный коммит или другой указатель и копирует.

Формат
git checkout <путь>

Пример
# Передвинем HEAD на два коммита назад
$ git checkout HEAD~2
HEAD is now at 7194f7e L-04: Fixing gradient bug
```

Можно заметить, что синтаксис совершенно такой же, как и в переключении ветки из предыдущего урока. Все верно, ведь переключение ветки – ни что иное, как передвижение указателя HEAD с указателя одной ветки на указатель другой. Чтобы подробно разобраться, что происходит при передвижении указателя, давайте рассмотрим пример. Изначально у нас есть такой репозиторий.

![](../imgs/githead.png)

Серыми овалами обозначены коммиты, текст на них – часть хэша соответствующего коммита. Коричневым прямоугольником обозначен указатель ветки: она у нас одна и называется main. Белым прямоугольником обозначен указатель HEAD, иногда его называют курсором. Его-то мы и будем двигать. Давайте попробуем сдвинуть HEAD на два коммита назад (то есть на коммит с хэшем 90ab…) и посмотрим, что будет.

```
$ git checkout HEAD~2
Note: switching to 'HEAD~2'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 90abf7e L-04: Fixing gradient bug
```

Предупреждение Git мы разберем чуть ниже, а сейчас давайте посмотрим, в каком состоянии мы оказались.

![](../imgs/githead-2.png)

Как видно из рисунка, указатель HEAD сейчас действительно передвинут на два коммита назад. Но указатель ветки main остался на месте и все еще указывает на последний коммит. Такое состояние, когда HEAD указывает не на указатель ветки, а непосредственно на сам коммит, называется detached head.

Detached head (англ. дословно – отрубленная голова, имеется в виду указатель HEAD, отключенный от графа) – состояние, при котором указатель HEAD не указывает ни на одну из веток репозитория, а ссылается непосредственно на сам коммит.

Если прочесть предупреждение Git выше, можно заметить, что он сообщает нам, что мы оказались в состоянии detached head. Давайте рассмотрим несколько особенностей этого состояния:

### История выводится не полностью

Действительно, если мы из текущего состояния выполним команду git log:

```
$ git log --pretty=oneline
90abf7ef211229adfa4cb75e0f35a0561dd15467 (HEAD)  L-04: Fixing gradient bug
3a3bb706651a19013822c09e5c70c9fc425a66dc L-04: Adding gradient function
d469222a7a760daa3cd56747e216e3de2a3343ee L-04: Initial commit
```

Видно, что вывелись только те коммиты, которые были сделаны позже коммита, на котором сейчас стоит HEAD. Если же мы хотим просмотреть всю историю, нужно воспользоваться ключом --all:

```
$ git log --all --pretty=oneline
62aa1ffe0587c7ffa3d865a3233da04d65818030 (main) L-04: Adding autograd
33ff7207fed9cbb34c9f3334249ef0707477f278 L-04: Adding neuron class
90abf7ef211229adfa4cb75e0f35a0561dd15467 (HEAD)  L-04: Fixing gradient bug
3a3bb706651a19013822c09e5c70c9fc425a66dc L-04: Adding gradient function
d469222a7a760daa3cd56747e216e3de2a3343ee L-04: Initial commit
```

Тогда нам видна полная история репозитория. Если присмотреться, то можно увидеть, что напротив первого сверху коммита в скобках написано main. Так Git сообщает нам, что на данный коммит указывает ветка main. Аналогично с третьим сверху коммитом: напротив него написано HEAD. Это означает, что HEAD указывает на этот коммит.

### Как переключиться обратно

Вам вовсе необязательно смотреть полную историю каждый раз, когда вы хотите вернуться обратно на ветку main. В предыдущем уроке мы рассматривали команду git checkout - и говорили, что с ее помощью можно вернуться на ветку, с которой мы переключились на текущую. Так вот, эта команда работает не только для веток, но и для любых перемещений HEAD. Если мы хотим перенести HEAD обратно, достаточно выполнить:

```
$ git checkout -
Previous HEAD position was 90abf7e L-04: Fixing gradient bug
Switched to branch 'main'
```

Как видно по выводу Git, мы успешно вернулись обратно на ветку main и вышли из состояния detached head.

У данного способа есть один минус: если вы "прыгали" по коммитам репозитория несколько раз, то git checkout - вернет вас на последний коммит, на котором вы были, а не на ветку main. В данном случае поможет простое и гениальное:

```
$ git checkout main
Previous HEAD position was 90abf7e L-04: Fixing gradient bug
Switched to branch 'main'
```

То есть мы напрямую указываем Git, что хотим переключиться на ветку main (или любую другую), таким образом выходя из состояния detached head.

### Зачем может понадобиться переключать указатель на старые коммиты, и важные особенности состояния "detached head".

На самом деле, все зависит от конкретной задачи и проекта, над которым вы работаете. Вообще состояние detached head на практике используется довольно-таки редко. Но все же можно привести несколько примеров использования этого состояния:

Пример 1
Самый банальный пример – просмотр файлов в определенном коммите. Допустим, вы хотите просмотреть содержимое файла main.py в коммите с определенным хэшем.
Просто выполните:

```
# Команда cat выводит в консоль содержимое файла.
$ git checkout 5df3f7e
$ cat main.py
print(“Hello world”)
```

Таким образом, вы можете просмотреть содержимое любого, когда либо закоммиченного файла, что бывает довольно удобно.

Пример 2
Кроме того, когда вы работаете над большим проектом, может быть нужно вернуться на несколько коммитов назад и создать свою ветку оттуда: например, чтобы протестировать экспериментальную функцию в том состоянии проекта. Сделать это можно так:

```
# Переключим указатель HEAD на определенный коммит:
$ git checkout 9a4e88b

# Теперь создадим новую ветку
$ git checkout -b feature
Switched to a new branch 'feature'

# Добавим файл и сделаем коммит
$ echo "just docs we forgot to put" > docs.md
$ cat docs.md
just docs we forgot to put

$ git add -A
$ git commit -m "L-04: Adding docs"
[feature d5e3273] L-04: Adding docs
 1 file changed, 1 insertion(+)
 create mode 100644 docs.md
```

Теперь у нас есть целая ветка feature, которая берет свое начало с коммита 9a4e88b. На ней мы можем проводит эксперименты с тем состоянием репозитория, которое было несколько коммитов назад, не боясь навредить остальной части репозитория.

Заметьте, что когда мы создали и переключились на ветку, мы вышли из состояния detached head. Если бы мы сделали коммит, не создавая для этого ветки, этот коммит оказался бы "оторванным" от истории: на него не ссылалась бы ни одна ветка, а в выводе истории (даже полной) его не было бы видно. Иначе говоря, если бы мы сделали коммит без ветки, мы бы смогли получить к нему доступ только запомнив его хэш наизусть.

Поэтому с состоянием detached head следует быть очень осторожным: если забыть создать новую ветку и начать делать коммиты, их можно с легкостью потерять.

На самом деле, если вы сделали несколько коммитов из состояния detached head и забыли создать ветку, ничего страшного: ветку можно создать прямо сейчас. Рассмотрим пример с тем же репозиторием:

```
# Переключимся в состояние “detached head” на ветке main.
$ git checkout d5e3273

# Теперь мы создадим несколько коммитов, исключительно для примера:
$ echo 'print('hello world')' > hello_world.py
$ echo 'print('Hi')' > say_hi.py
$ echo 'Some text file' > about.txt
$ git add hello_world.py
$ git commit -m "L-04: Adding hello_world.py"
[detached HEAD d013c75] L-04: Adding hello_world.py
 1 file changed, 1 insertion(+)
 create mode 100644 hello_world.py

$ git add say_hi.py
$ git commit -m "L-04: Adding say_hi.py"
[detached HEAD 58f8c22] L-04: Adding say_hi.py
 1 file changed, 1 insertion(+)
 create mode 100644 say_hi.py

$ git add about.txt
$ git commit -m "adding about.txt"
[detached HEAD 7c10724] L-04: Adding about.txt
 1 file changed, 1 insertion(+)
 create mode 100644 about.txt

# А сейчас мы вспомнили, что сделали несколько коммитов в состоянии “detached head” и испугались, что потеряем их. Но не стоит бояться, можно просто создать ветку прямо сейчас:
$ git checkout -b feature
Switched to a new branch 'feature'

# И чтобы убедиться, что мы не потеряли ни одного коммита, давайте взглянем на историю ветки feature
$ git log --pretty=oneline main..feature
7c10724b12dba69ed1acf4c6fef804c251f7c290 (HEAD -> feature) L-04: Adding about.txt
58f8c226952d500df7a9c2f798011ab20165a286 L-04: Adding say_hi.py
d013c75418ac71ca8f4578583aa23d7567dab332 L-04: Adding hello_world.py
d5e327368d12d6e5ef5b04e16af1d96319069805 L-04: Adding docs
```

Даже в состоянии detached head коммиты сохраняют родительские отношения, то есть каждый коммит знает, кто его предшественник. Поэтому мы в любой момент можем восстановить их последовательность, если найдем крайний коммит в данной цепочке. То есть для нас главное не забыть создать ветку, находясь в состоянии detached head. А вот создать ее можно в любой момент: до того, как мы сделаем первый коммит из этого состояния, или в любой другой момент – не важно, главное сделать это до переключения на другую ветку или коммит. Тогда у нас будет ссылка на крайний коммит ветки, а по его родителям мы сможем определить всю последовательность.

Подведем итог
1. Указатель HEAD можно перемещать на разные коммиты, точно так же, как мы перемещали его между ветками. Для этого нужно использовать команду git checkout.
2. Когда мы перемещаем HEAD с указателя ветки на коммит, мы попадаем в состояние detached head.
3. В состоянии detached head стоит быть осторожным: если планируете делать коммиты, лучше сразу создайте ветку командой git checkout -b <имя ветки>.
4. Если вы сделали несколько коммитов из состояния detached head, забыв создать ветку – ничего страшного, ветку можно создать в любой момент.
5. Обычно detached head используется редко, но вы можете использовать его, чтобы просматривать старые версии файлов или экспериментировать с предыдущими версиями проекта.

## Откат коммитов. Команда git revert.

Пожалуй одна из самых важных частей в изучении Git – научиться откатываться к предыдущим коммитам. Смысл отката мы обсуждали в предыдущих уроках: ваш проект может перестать работать по непонятным вам причинам после внесения некоторых изменений в код, в таком случае важно быстро вернуть все к рабочему состоянию и только потом заниматься поиском ошибки. В этом-то случае нам и поможет откат коммитов и команда git revert.

Суть работы данной команды в том, что она создает новый коммит, который отменяет изменения внесенные в переданном коммите (последовательности коммитов).

```
Команда git revert

Что делает
Отменяет изменения, внесенные в переданном коммите.

Ключи
-n
Не делает коммит. С данным ключом изменения коснутся только рабочей копии.

--abort
Данный ключ используется только при разрешении конфликтов.
Прерывает выполнение команды после разрешения конфликтов.

--continue
Данный ключ используется только при разрешении конфликтов.
Продолжает выполнение команды после разрешения конфликтов.

Пример
# Отменим изменения, внесенные 2 коммита назад
$ git revert HEAD~2

# Отменим все изменения в коммитах, начиная с пятого с конца и заканчивая вторым с конца.
$ git revert HEAD~5..HEAD~2
```

Команда git revert очень важна, поэтому давайте разберем, как с ней работать. Рассмотрим самый простой пример, в котором у нас не возникнет файловых конфликтов. Допустим, мы хотим отменить изменения предпоследнего коммита. Главное, что здесь нужно запомнить – это что у нас не должно быть незакоммиченых изменений в рабочей директории, ведь мы все-таки делаем реверт-коммит. Если у вас есть таковые, лучшим решением станет закоммитить (или удалить) все изменения, и только потом делать реверт.

```
# Выполним реверт предпоследнего коммита. Кстати, такой реверт никогда не вызовет конфликтов.

$ git revert HEAD~1

# Как только мы выполним команду, будет открыт консольный редактор, чтобы вы могли отредактировать сообщение нового коммита. Можно что-то дописать, можно сразу закрыть редактор сочетанием Ctrl+X (здесь приведено сочетание для редактора “nano”). Решать вам. В нашем случае окно редактора будет выглядеть так.

Revert "L-04: Addit docs.txt"

This reverts commit aadfbc3a6756289727e56ac3de59004e66e40033.

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
# Your branch is up to date with 'origin/master'.
#
# Changes to be committed:
#       modified:   docs.txt
#



^G Get Help  ^O Write Out ^W Where Is  ^K Cut Text  ^J Justify   ^C Cur Pos
^X Exit      ^R Read File ^\ Replace   ^U Paste Text^T To Spell  ^_ Go To Line

# После закрытия редактора, в терминал будет выведена информация об успешном реверте коммита

[main e933971] Revert "addit docs.txt"
 1 file changed, 1 insertion(+), 1 deletion(-)
```

Итак, это был самый простой пример. В основном сложности git revert связаны с разрешением файловых конфликтов. Разрешать мы их научимся в следующем уроке, а пока давайте обсудим, из-за чего может возникнуть конфликт. Может, обладая этими знаниями и столкнувшись с конфликтом во время выполнения git revert,вы поймете, что вам совсем не нужен откат.

Иногда при отмене изменений может возникнуть ситуация, когда в файл в рабочей копии были внесены изменения с момента коммита находится не в том же состоянии, как в коммите, который мы отменяем. Звучит сложно, поэтому давайте приведем пример. Допустим, у нас есть следующий репозиторий.

![](../imgs/gitrevert.png)

В каждом из вышеуказанных коммитов всего один файл: docs.md. Над хэшем каждого коммита на рисунке указано содержимое docs.md, которое было внесено в данный коммит.

Теперь, когда перед глазами у вас есть диаграмма, давайте разберемся, в каком случае при откате возникнет конфликт файлов. На самом деле, конфликт возникнет при откате любого, кроме самого последнего коммита. Как мы уже говорили, при реверте коммита, его изменения отменяются, то есть файлы возвращаются к состоянию предыдущего коммита. Например, если мы попробуем откатить коммит 33ff, то содержимое файла docs.md изменится с

```
Содержимое docs.md, коммит 33ff
Some docs here
and here
```

на

```
Содержимое docs.md, коммит 90ab
Some docs here
```

Но ведь в последнем коммите, т.е. в рабочей копии находится файл, содержимое которого

```
Содержимое docs.md, коммит c732f69
Some docs here
and here
also here
```

что совсем не соответствует содержимому коммита, который мы откатываем. То есть с момента того коммита мы уже успели изменить файл docs.md, и теперь Git не очень понимает, как именно делать откат:
оставить файл в рабочей копии нетронутым или,
наоборот, заменить файл в рабочей копии на файл после отката.

Поэтому и возникает конфликт. Git напрямую спрашивает у нас: "Какой файл мне оставить?". На практике это выглядит вот так:

```
# Пробуем откатить коммит .
$ git revert 33ff381
Auto-merging docs.md
CONFLICT (content): Merge conflict in docs.md
error: could not revert 33ff381... L-04: Adding info to docs
hint: after resolving the conflicts, mark the corrected paths
hint: with 'git add <paths>' or 'git rm <paths>'
hint: and commit the result with 'git commit'
```

В следующем уроке, когда мы будем говорить о слиянии веток, мы научимся разрешать файловые конфликты.

Кстати, если вы попали в ситуацию, когда Git сообщил вам о конфликте файлов, а вы такого не ожидали, или вы просто передумали делать откат из-за конфликта, можете в любой момент выполнить git revert --abort. Это остановит откат, и вы сможете спокойно разобраться, откуда возникает конфликт.

Подведем итог
1. git revert – команда, отменяющая изменения переданного коммита. Она заменяет файлы в рабочей копии на файлы предка переданного коммита, а затем делает коммит, чтобы сохранить изменения.
2. Иногда во время отката возникают конфликты. Их не стоит бояться, но нужно быть внимательным и разобраться, откуда возникает конфликт.
3. Если вы столкнулись с конфликтом во время отката и передумали продолжать git revert, выполните команду git revert --abort. Она вернет все как было и отменит откат.
4. В сообщении реверт-коммита следует указывать полезную информацию: зачем вы сделали откат, каким образом вы сливали файлы, если были конфликты, и т.д.


## Удаление и объединение коммитов. Команда git reset.

Помните, мы говорили про команду git checkout и перемещение указателя HEAD? Тогда мы перемещали только сам указатель HEAD и попадали в состояние detached head. Команда git reset позволяет нам перемещать указатель ветки вместе с указателем HEAD. Давайте разберем эту команду подробнее.

```
Команда git reset

Что делает
Переносит указатель ветки на переданный коммит.

Ключи
--soft
С этим ключом, команда не отменяет изменения ни в индексе, ни в рабочей копии. Все ваши файлы останутся в том же состоянии, в котором были, но указатель ветки будет передвинут.

--hard
С этим ключом команда удалит все изменения так, чтобы состояние индекса и рабочей копии полностью соответствовали коммиту, к которому мы сделали reset

Пример
# Сделаем reset последнего коммита, который мы сделали по ошибке. При этом оставим файлы в том же состоянии.
$ git reset --soft HEAD^

# Отменим последние три коммита и удалим все изменения в файлах.
$ git reset --hard HEAD~3
HEAD is now at 2f96b73 L-04: Create main.py
```

Чтобы лучше понять смысл этой команды приведем граф репозитория. Изначально он выглядел так.

![](../imgs/gitreset.png)

Теперь выполним "мягкий" reset последних двух коммитов.

```
$ git reset --soft HEAD~2
```

Теперь наш граф выглядит так.

![](../imgs/gitreset-2.png)

Причем файлы в рабочей копии остались в том же состоянии, что и были в коммите 62aa.

Как видно из рисунка, Git создал новый указатель – ORIG_HEAD. Этот указатель создается при выполнении команды git reset и ссылается на тот коммит, от которого мы делали reset. Как мы увидим ниже, это очень полезный в работе с git reset указатель.

Кстати, если мы сейчас сделаем коммит:

```
$ git add -A
$ git commit -m “L-04: Reset commit”
[main 03953f8] L-04: Reset commit
 1 file changed, 3 insertions(+), 1 deletion(-)
```

То получим такую картину:

![](../imgs/gitreset-3.png)

То есть наш коммит пойдет по ответвлению от исходной ветки main. Поэтому будьте внимательны, создавая новые коммиты.

Итак, теперь поговорим, как на практике используется git reset. В основном, все использование сводится к трем пунктам:
1. Редактирование/отмена последнего коммита.
2. Объединение нескольких коммитов в один.
3. Удаление коммитов.
4. Отмена изменений команды git reset.

Давайте подробно разберем каждый пункт.

### Редактирование или отмена последнего коммита

Если вы случайно опечатались в сообщении последнего коммита, или хотите добавить в него файлов, то git reset поможет вам. Но прежде всего нам нужно разобрать новые ключи уже знакомой команды git commit. Они потребуются нам в дальнейшем.

```
Команда git commit

Что делает
Создает новый коммит.

Ключи
-С
С этим ключом, команда, создавая новый коммит, возьмет сообщение и информацию об авторе из переданного коммита.

-с
С этим ключом, команда, создавая новый коммит, возьмет сообщение и информацию об авторе из переданного коммита, а затем откроет редактор, чтобы вы могли отредактировать сообщение коммита.

--amend
С этим ключом коммит будет объединен с последним коммитом на текущей ветке. Этот ключ используется для редактирования содержимого и сообщения последнего коммита.

Пример
# Сделаем новый коммит с таким же сообщением и информацией об авторе, как у коммита, на который указывает ветка feature.
$ git commit -C feature

# Сделаем то же самое, но отредактируем сообщение коммита.
$ git commit -с feature
```

Теперь, когда мы познакомились с новыми ключами, можем перейти к редактированию последнего коммита. Последовательность действий в данной ситуации такая:
Откатиться к предпоследнему коммиту командой git reset --soft HEAD^
Добавить в коммит новые файлы, если вам это нужно, использовав команду git add.
Выполнить git commit -c ORIG_HEAD, если вы хотите отредактировать сообщение, или git commit -C ORIG_HEAD, если вы хотите оставить сообщение коммита без изменений.

Полезно знать
Кстати, данная последовательность команд идентична git commit --amend. Чтобы отредактировать последний коммит, следуйте инструкции:
1. Если вы хотите добавить в коммит файлы, то для начала добавьте их в индекс командой git add <имя файла>. Если не хотите, то проверьте, что проиндексированных изменений нет, иначе они будут добавлены в последний коммит.
2. Выполните
git commit --amend. Тогда откроется консольный редактор, где вы сможете отредактировать сообщение последнего коммита.
git commit --amend -m "<новое сообщение>". Тогда сообщение последнего коммита будет заменено на <новое сообщение>.

В случае, если же вы хотите насовсем удалить последний коммит, просто выполните

```
$ git reset --hard HEAD^
HEAD is now at c732f69 L-04: Adding more info to docs
```

Таким образом, последний коммит будет удален и не будет отображаться в логе. Тем не менее, вернуться к нему вы сможете по указателю ORIG_HEAD, который оставит Git.

### Объединение нескольких коммитов в один.

Иногда на практике возникают ситуации, когда для удобства восприятия и красивой истории необходимо объединить несколько последних коммитов в один. Порядок действий тут почти такой же, как и в случае редактирования последнего коммита:

Выполните git reset --soft HEAD~n, где n это число коммитов, которые вы хотите объединить. Эта команда вернет указатель ветки на n коммитов назад, оставив изменения в индексе и рабочей копии нетронутыми. То есть после выполнения этой команды вы откатитесь на n коммитов назад, но все изменения внесенные этими коммитами останутся у вас в рабочей копии и индексе.
Выполните git commit -c ORIG_HEAD, а затем отредактируйте сообщение коммита должным образом. Эта команда сделает коммит всех изменений в индексе. То есть она сделает коммит, который по своему содержимому представляет объединение последних n коммитов.

Собственно, это все. То есть на самом деле мы просто откатили последние несколько коммитов, а затем создали новый коммит, который собирает в себе все их изменения. При этом изначальные коммиты никуда не делись. Их не будет видно в истории, но если вы помните их хэш, то в любой момент сможете переключиться на любой из них с помощью команды git checkout.

### Удаление последних нескольких коммитов.

Пожалуй, самая простая ситуация. Чтобы удалить последние n коммитов, выполните

```
$ git reset --hard HEAD~n
```

Где n – это, конечно, какое-то конкретное число. После этого удаленные коммиты не будут выводиться в истории (совсем, даже с флагом --all).

### Отмена изменений команды git reset.

Если вы каким-то образом случайно выполнили git reset и решили все вернуть, просто переместите указатель ветки обратно, использовав команду

```
$ git reset ORIG_HEAD
```

Эта команда вернет указатель ветки на коммит, с которого вы делали git reset, и вы вернете все изменения, даже если использовали ключ --hard.

Подведем итог
Итак, мы выучили новую команду git reset. Она используется, чтобы перемещать указатель ветки по графу Git. На практике ее в основном применяют для
- Редактирования или удаления последнего сделанного коммита.
- Объединения последних нескольких коммитов в один.
- Удаления последних нескольких коммитов.
- После использования git reset, Git создаёт указатель ORIG_HEAD, который ссылается на коммит, с которого мы сделали reset.


Не стоит забывать, что даже если вы использовали git reset --hard, вы всегда можете вернуть все к изначальному состоянию, выполнив git reset ORIG_HEAD. Это вернет указатель ветки на коммит, с которого вы делали reset.

## Различие команд git reset и git checkout и git revert

Сегодня мы изучили несколько команд, которые на первый взгляд очень похожи друг на друга. Давайте разберемся, в чем разница между ними. Для начала приведем краткую справку, чтобы напомнить, что делает каждая из команд.

```
Команда git revert
Данная команда создает новый коммит, который отменяет действие одного из предыдущих коммитов. То есть новый коммит появится в истории, а предыдущие коммиты не изменятся.
```

```
Команда git reset
Работа этой команды зависит от вызова. Если вызвать git reset <ссылка>, то команда переместит ветку, на которую указывает HEAD, на переданную ссылку. Затем, в зависимости от опций --soft/--hard/--mixed, команда:
либо останавливается,
либо обновляет индекс и рабочую копию так, чтобы они соответствовали текущему коммиту,
либо обновляет только индекс соответственно.

То есть она изменит историю, исключив из нее все коммиты, оставшиеся после HEAD. Говоря проще, команда действует так:
Перемещает ветку, на которую указывает HEAD, или только HEAD (если он находится в состоянии detached HEAD). Останавливается на этом шаге, если передан ключ --soft.
Делает индекс таким же, как в коммите, на который указывает HEAD. Останавливается на этом шаге, если не передан ключ --hard.
Делает рабочую копию такой же, как коммит, на который указывает HEAD

Вы также можете вызвать основную команду (без ключей --hard и --soft), передав ей путь к файлу: git reset <ссылка> <имя файла>. В этом случае команда будет действовать также, но эффект будет отличаться, поэтому этот случай стоит рассмотреть отдельно.

В случае, если вы не передали ссылку, вместо нее будет подставлен HEAD. То есть она обновит индекс так, чтобы он соответствовал коммиту, на который указывает HEAD. Иначе говоря, скопирует файл из HEAD в индекс. То есть ее действие противоположно git add <имя файла>: она отменит добавление файла в индекс.

Если же вы указали ссылку, то в вашем индексе окажется файл из одного из предыдущих коммитов. То есть в рабочей копии файл не изменится, но если вы сразу же сделаете коммит, то в новом коммите будет файл из одного из предыдущих коммитов.
```

```
Команда git checkout
Действие этой команды тоже зависит от вызова.
Если вызвать git checkout <ссылка>, то команда либо перемещает указатель HEAD на переданную ссылку (т.е. на другую ветку или коммит). Историю данная команда не меняет, если только не забыть использовать ключ --all: git log --all.
Если выполнить git checkout <ссылка> <имя файла>, то команда скопирует содержимое файла из переданного коммита в рабочую копию и индекс.
```

```
Команда git restore

Копирует файл из переданной ссылки в рабочую копию, индекс или сразу и туда, и туда. Изначально эта команда появилась, как аналог git checkout <ссылка> <имя файла>, но ее функционал немного шире. Данная команда также не меняет историю.
```

Между git checkout, git reset и git restore есть несколько различий:

1. Команда git checkout <ссылка> похожа на git reset --hard <ссылка>: в обоих случаях перемещается HEAD и меняется рабочая копия. Однако есть и разница:.
Первое отличие состоит в том, что git checkout перемещает только HEAD, в то время как git reset перемещает HEAD и ветку, на которую указывает HEAD.
Еще одно отличие заключается в том, что git checkout проверяет, что у вас в рабочей копии нет измененных файлов, в то время как git reset просто заменяет все файлы без разбора.

В случае, когда мы находимся в состоянии detached head и у нас нет измененных файлов, эти две команды идентичны.

2. Команда git checkout <ссылка> <имя файла> также имеет общие черты с git reset <ссылка> <имя файла>. Отличие состоит в следующем:

git checkout <ссылка> <имя файла> изменяет и рабочую копию, и индекс, в то время, как git reset <ссылка> <имя файла> меняет только индекс. Кстати, идентичной командой для git checkout <ссылка> <имя файла> была бы команда git reset --hard <ссылка> <имя файла>, если бы ее можно было так использовать: это очень небезопасно для рабочей копии.

3. Команда git restore задумывалась как аналог git checkout <ссылка> <имя файла>. Тем не менее, между ними есть следующие отличия:
Используя git checkout <ссылка> <имя файла>, в качестве ссылки вы можете передать только определенный коммит, в то время как git restore может скопировать файл в рабочую копию прямо из индекса
Команда git checkout всегда копирует файлы одновременно и в рабочую копию, и в область индекса, что не всегда удобно. В свою очередь, git restore может принять ключи --staged и --worktree, определяющие, скопировать файл только в область индекса, только в рабочую копию, или сразу в оба места.

Для закрепления, давайте приведем таблицу сравнения команд git revert, git reset, git checkout и git reset по их взаимодействию с указателем HEAD, историей, индексом и рабочей копией.

##### <a name="Glava_5"> # Глава 5. Слияние изменений и продвинутая работа с ветками. Команды: merge, cherry-pick, rebase.

Сегодня мы познакомимся с очень важным для работы в команде функционалом: слиянием веток, ребейзом коммитов и cherry-pick`ом. Также мы узнаем, чем слияние отличается от rebase и cherry-pick, и в каком случае какую команду использовать.

## Что такое слияние и зачем оно нужно

Перед началом урока давайте освежим в памяти информацию из предыдущих:

1. Ветка – независимая последовательность коммитов. Ветки нужны, чтобы тестировать новые функции и распараллеливать работу над проектом.
2. Первоначально мы работаем в основной ветке. У нас она называется main.

Обычно в основной ветке находится та же версия кода, что и в продакшене. То есть если в основную ветку попадут какие-то непроверенные изменения, код может сломаться и повлечь за собой поломку приложения у конечного пользователя. Поэтому во всех командах, работающих над серьезными проектами, принято, что в основной ветке находятся только протестированные изменения, которые в идеале не придется экстренно исправлять.

То есть общий ход нашей работы выглядит следующим образом:
1. Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке.
2. Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код.
3. Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит слияние: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.

Итак, дадим определения:

Сливаемая ветка – та ветка, с которой мы берем изменения, чтобы влить их в целевую.

Целевая ветка – та ветка, в которую мы сливаем наши изменения.

Слияние веток – это перенос изменений с одной ветки на другую. При этом слияние не затрагивает сливаемую ветку, то есть она остается в том же состоянии, что позволяет нам потом продолжить работу с ней.
Теперь давайте перейдем к тому, как слияние реализовано в Git.

## Слияние в Git. Команда git merge.

Чтобы выполнить мердж (от англ. merge – слияние), в Git предусмотрена команда git merge.

```
Команда git merge

Что делает
Сливает изменения с переданной ветки в текущую.

Формат
git merge <сливаемая ветка>

Ключи
--ff , --no-ff и --ff-only
Эти ключи определяют стратегию слияния. Подробнее о стратегиях мы поговорим чуть ниже, а пока перечислим назначения каждого из ключей.
--ff – включить fast-forward, если это возможно,
--no-ff – отключить fast-forward,
а --ff-only – остановить merge, если его невозможно сделать fast-forward.

--abort
Ключ, использующийся только при разрешении конфликтов. Позволяет прервать слияние и вернуть все к моменту начала операции.

--continue
Ключ, использующийся только при разрешении конфликтов. Позволяет продолжить слияние после разрешения всех конфликтов.

Пример
# Переключимся на основную ветку
$ git checkout main
# Сольем изменения с ветки develop в ветку main
$ git merge develop
Обновление d078c8d..4a2f9b1
Fast-forward
main.py | 33 +++++++++++++++++++++++++++++++++
README.md | 23 +++++++++++++++++------
bot.py | 6 ++++++
3 files changed, 56 insertions(+), 6 deletions(-)
create mode 100644 main.py
create mode 100644 bot.py
```

Теперь, когда мы узнали, как выполнить простейшее слияние в Git, можно поговорить о нем подробнее. Давайте разберем стратегии слияния.

Стратегия слияния – это набор правил, которыми руководствуется Git при выполнении слияния.

Существует две основных стратегии слияния:
1. Явное слияние
2. Неявное слияние.

Их различие заключается в том, что при явном всегда создается новый коммит, а при неявном – используются существующие коммиты.

### Явное слияние

Во время явного слияния создается так называемый merge-коммит. Основное предназначение этого коммита состоит в том, чтобы "соединить" изменения двух веток. У этого коммита есть одна особенность: два родительских коммита. Один родитель – последний коммит сливаемой ветки, второй – последний коммит целевой ветки.

Допустим, у нас есть граф вида:

![](../imgs/gitmerge.png)

То есть у нас есть две ветки: main – основная и develop – ветка для разработки новых функций. Давайте посмотрим, что будет происходить, если мы выполним команду:

```
$ git checkout main
$ git merge --no-ff develop
```

Флаг --no-ff в данной ситуации необходим, поскольку мы хотим выполнить именно явное слияние. Подробнее о смысле этого флага мы поговорим чуть позже.

Итак, git merge делает следующие шаги:
1. Проверяет, нет ли конфликтов, т.е. не удалят и не перепишут ли наши изменения какую-либо уже существующую информацию. Если возникает конфликт git merge останавливается, чтобы получить инструкции от пользователя, но этот случай мы рассмотрим ниже. А пока допустим, что конфликтов нет.
2. Добавляет все изменения из коммитов 3-5 в индекс ветки main
3. Делает коммит

После git merge граф репозитория будет выглядеть следующим образом:

![](../imgs/gitmerge-2.png)

Полезно знать
Заметим, что в данном случае (то есть если не возникло конфликтов слияния), git merge эквивалентен командам git checkout develop * и git commit -a "Merge commit "– то есть копированию всех файлов с ветки develop в рабочую копию текущей ветки и последующему созданию коммита.

Кстати, коммит Merge commit действительно имеет двух родителей: Commit-5 с ветки develop и Commit-2 c ветки main. Это усложнит откат этого коммита, поэтому будьте предельно внимательны, выполняя git merge.

### Неявное слияние

Во время неявного слияния не создается новых коммитов: используются только уже существующие. Суть этого слияния заключается в том, что из вливаемой ветки извлекаются несколько коммитов, а затем они применяются к последнему коммиту целевой ветки. Такое слияние называется fast-forward.

Давайте рассмотрим пример. Допустим, у нас есть все тот же граф репозитория:

![](../imgs/gitmerge-3.png)

Попробуем выполнить слияние, но уже без флага --no-ff:

```
$ git checkout main
$ git merge develop
```

Тогда git merge поступит так:
- Проверит, что в ветке main нет коммитов, сделанных после ответвления develop.
- Проверит, что не возникает конфликтов, если конфликты возникнут, Git попросит пользователя разрешить их.
- Перенесет указатель main на Commit-5. Теперь ветка develop как бы стала веткой main.

Графически ситуация выглядит следующим образом:

![](../imgs/gitmerge-4.png)

Как видно из рисунка, новый коммит действительно не был создан. Вместо него, Git "подставил" в ветку main уже существующие коммиты из ветки develop.

Стоит подробнее разобрать первый пункт в работе git merge. В нем говорится, что Git проверит, что в ветке main нет коммитов, после ответвления develop. Дело в том, что режим fast-forward возможен не всегда, например в случае такого репозитория:

![](../imgs/gitmerge-5.png)

Слияние в режиме fast-forward выполнить будет невозможно, поскольку в таком случае мы потеряем всю информацию о Коммите-6. Не будет активных ссылок, указывающих на этот коммит, или одного из его наследников: последующих коммитов, для которых Коммит-6 стал родителем. Поэтому в данном случае придется выполнять явный git merge с созданием merge-коммита.

Полезно знать
Кстати, по умолчанию git пытается выполнить слияние именно в режиме fast-forward. Поэтому когда мы разбирали явное слияние, нужно было указать флаг --no-ff: без него Git выполнил бы merge в режиме fast-forward.

Подытожим: В чем разница между fast-forward и явным слиянием?

Режим fast-forward считается более удобным, поскольку в нем не нужно создавать лишних merge-коммитов, засоряющих историю репозитория. С другой стороны, если мы продолжим пользоваться веткой develop после fast-forward слияния, потом будет довольно трудно разобраться в ее истории. Так что каждый раз выполняя слияние, задумайтесь, хотите ли вы, чтобы оно прошло в режиме fast-forward, или для вас лучше явно создать merge-коммит, собирающий все воедино.

## Разрешение конфликтов слияния

Очень часто во время слияния веток оказывается, что ваши изменения удаляют или переписывают информацию в уже существующих файлах. Такая ситуация называется файловым конфликтом. Git останавливает выполнение слияния, пока вы не разрешите конфликт.

По сути, Git сталкивается с проблемой: у него есть два файла с одним и тем же именем, и он не знает, какой из них взять. Поэтому обращается к нам за помощью.

Давайте сразу начнем с примера и по ходу будем учиться разрешению конфликтов. Так будет нагляднее. Итак, допустим есть следующий репозиторий:

![](../imgs/gitconflict.png)

Чтобы не перегружать себя лишней информацией, будем рассматривать всего один файл: Docs.md. Содержимое этого файла в различных коммитах приведено на рисунке, но для удобства продублируем его:

Содержимое Docs.md, C2
```
- This is documentation
```

Содержимое Docs.md, C6
```
- This is documentation
- It contains lots of info
```

Содержимое Docs.md, C5
```
- This is documentation
- New feature info
- It has lots of info
```

Наша задача состоит в том, чтобы слить ветку develop в ветку main. Давайте попробуем сделать это.

```
$ git merge develop
Auto-merging Docs.md
CONFLICT (content): Merge conflict in Docs.md
Automatic merge failed; fix conflicts and then commit the result.
```

Вот так Git и сообщает нам о конфликте: в файле Docs.md из коммита C5 вторая строка переписывает вторую строку фалйа Docs.md из коммита C6. Таким образом Git просит нас разобраться, какой файл оставлять. Давайте научимся делать это.

Общий подход к разрешению конфликтов такой:
1. Непосредственно разрешить конфликт одним из двух рассмотренных немного ниже способов. Либо, если возникновение конфликта стало неожиданным для вас, можно выполнить git merge --abort. Эта команда прервет слияние и вернет все, как было.
2. Сообщить Git, что мы разрешили конфликт, добавив все файлы с разрешенными конфликтами в индекс. Сделать это можно уже знакомой командой git add <конфликтный файл> для каждого конфликтного файла.
3. Продолжить слияние, выполнив git merge --continue. Либо вручную создать merge-коммит уже знакомой командой git commit.

Выше мы уже сказали, что существует два способа разрешать конфликты, вот они:
Первый способ. Разрешить конфликт вручную. Тогда мы можем самостоятельно изменить конфликтные файлы, сделав их такими, какими мы хотим их видеть.
Второй способ. Просто выбрать один из двух файлов.

Разберем каждый из них по очереди.

### Ручное разрешение конфликта

Для этого в любом текстовом редакторе откройте конфликтный файл (если файлов несколько, конфликт нужно устранять в каждом). Приведем содержимое файла Docs.md.

Содержимое Docs.md
```
- This is documentation
<<<<<<< HEAD
- It contains lots of info
=======
- New feature info
- It has lots of info
>>>>>>> develop
```

Видим, что Git оставил нам пометки, чтобы нам было проще устранять конфликт:
Текст до <<<<<<< HEAD – это общая часть двух файлов, она не конфликтует. В нашем случае оба файла имеют одинаковую первую строку: - This is documentation

Текст между <<<<<<< HEAD и ======= – это конфликтующее содержимое файла, на который указывает HEAD, то есть файла из целевой ветки. В нашем случае это вторая строка, именно она переписывается изменениями из ветки develop.

Все, что находится между ======= и >>>>>>> develop – это содержимое файла из ветки develop. В нашем случае это вторая и третья строки: - New feature info и - It has lots of info.

![](../imgs/gitconflict-2.png)

Наша задача – объяснить Git, каким мы хотим видеть файл Docs.md. Для этого нам нужно вручную отредактировать файл Docs.md. Нам не обязательно выбирать один из двух приведенных вариантов – в этом вся прелесть ручного редактирования. Мы можем удалить вообще весь текст из файла, оставить часть первого файла и часть второго или вообще написать что-то свое. Не забудьте удалить строки, которые оставил Git, то есть <<<<<<< HEAD, ======= и >>>>>>>develop, сами собой они не пропадут. В качестве примера, мы отредактировали конфликтный файл таким образом:

Содержимое docs.md
```
- This is documentation
- It contains lots of info
- New feature info
```

Теперь рассмотрим второй способ.

### Выбор одного из двух файлов

Если вы точно знаете, что вам нужно оставить только один из двух конфликтных файлов (вся информация из другого файла при этом потеряется), можно сказать об этом Git:
Выполните git checkout --ours Docs.md, чтобы выбрать файл ветки main (то есть целевой ветки)
Либо git checkout --their Docs.md, чтобы выбрать файл из ветки develop (то есть сливаемой ветки).
Эта команда скопирует в docs.md из рабочей копии содержимое одного из конфликтных файлов. То есть Git полностью заменит файл в рабочей копии выбранным вами файлом.

```
# Разрешим конфликт выбором файла из коммита, к которому мы откатываемся.
$ git checkout --their Docs.md
Updated 1 path from the index
```

Поздравляю, теперь конфликт разрешен! Кстати, если сейчас выполнить команду git status, нас ждет необычный вывод.

```
$ git status
On branch main
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Changes to be committed:
	new file:   new_feature.py

Unmerged paths:
  (use "git add <file>..." to mark resolution)
	both modified:   Docs.md
```

Как видим, Git добавил в индекс файл new_feature.py с ветки develop, поскольку этот файл не вызывал конфликтов. И вместе с тем пометил, что файл Doc s.md находится среди Unmerged paths, то есть Неслитых путей.

Конфликт разрешен, теперь нам осталось только сообщить о разрешении конфликта Git. Сделать это можно командой git add <filename> или git add -A, чтобы добавить в индекс сразу все файлы, конфликты которых разрешены. После этого следует сообщить Git, что мы можем продолжить слияние.

```
# Добавим наш файл в индекс.
$ git add Docs.md

# Ради интереса посмотрим статус
$ git status
On branch main
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:
	modified:   Docs.md
	new file:   new_feature.py
```

Видим, что Git сообщает нам, что все конфликты разрешены. Теперь можно либо вручную выполнить git commit, либо написать git merge --continue: разницы нет.

Дальше все стандартно: откроется редактор сообщения коммита. В сообщении следует указать, какие ветки вы сливали, и вкратце перечислить внесенные изменения.

```
# Продолжим слияние.
$ git merge --continue
[main a219fa1] L-04: Merge branch 'develop'
```

Теперь слияние полностью завершено.

### Тонкости разрешения merge-конфликтов.

Теперь мы имеем представление, как разрешать конфликты слияния, и пришло время углубиться в эту тему. Поговорим о тонкостях, которые помогут вам понять, как правильно разрешить конфликт. Подчеркиваем: "правильно", поскольку разрешить конфликт не составляет труда, но если сделать это неверно, можно потерять код, написанный другими разработчиками.

Допустим, вам дали репозиторий и поставили перед вами задачу: влить ветку develop в ветку main. Ну хорошо, это мы умеем делать, давайте выполним слияние.

```
$ git merge develop
Auto-merging colors.txt
CONFLICT (content): Merge conflict in colors.txt
Automatic merge failed; fix conflicts and then commit the result.
```

Вот мы и столкнулись с конфликтом. Давайте посмотрим на конфликтующий файл в любом текстовом редакторе.

Содержимое файла colors.txt
```
<<<<<<< HEAD
This color is red,
And this one is blue.
Check out the base
To make conflict solved by you!
=======
this color is (255, 36, 0)
and this one is (0, 191, 255)
check out the base
to make conflict solved by you
>>>>>>> develop
```

Видно, что файлы различаются, но из этого представления совсем непонятно, что именно должно войти в итоговый файл. Если бы это был ваш личный проект, вы бы прекрасно знали, какой из файлов выбрать, но это чужой репозиторий и цена ошибки велика. Конечно, можно потратить много времени, перебирая коммиты из обеих веток, разбираясь, как менялись файлы, чтобы понять, что должно быть в итоговом файле. Но можно поступить проще. Прежде всего, давайте изучим немного теории.

Итак, при слиянии двух веток используются четыре состояния, и три из них необходимы, чтобы разрешить конфликт правильно. Давайте разбираться, что это за состояния.

Эти состояния можно изобразить на диаграмме следующим образом.

![](../imgs/gitconflict-3.png)

Чтобы понять, что изображено на диаграмме, полезно будет вспомнить, что такое дельта.
Дельта – это разность каких-то двух состояний. То есть по сути это информация о том, какие изменения вы внесли в файлы с момента определенного коммита. Как мы помним из второго урока данного курса, коммиты хранят именно дельты, а не полностью файлы. Благодаря этому репозиторий Git занимает очень мало места.

На диаграмме выше Дельта-1 – это разность текущего состояния ветки main и базы слияния. Аналогично Дельта-2 – это разность текущего состояния ветки develop и базы слияния.

Перейдем к самим состояниям. В выводе файла выше нам были показаны только два состояния. На диаграмме они отмечены белым: это текущее состояние ветки main и текущее состояние ветки develop. То есть все, что находится между <<<<<<< HEAD и ======= – текущее состояние конфликтного файла в ветке main, и, соответственно, текст между ======= и >>>>>>> develop – состояние конфликтного файла в ветке develop. На диаграмме видно еще два состояния – базу слияния и результат слияния. Разберемся, что это за состояния.

Результат слияния нам как раз и нужно получить. Git пытается получить его автоматически, совмещая Дельту-1 и Дельту-2, но если эти дельты задевают одни и те же части одного и того же файла, возникает конфликт. При возникновении конфликта Git просит нас сравнить Дельту-1 и Дельту-2, чтобы составить из них третье состояние – результат слияния.

База слияния – это последний общий родитель конфликтных файлов. Говоря проще, это тот файл, применив к которому изменения из Дельты-1, мы получим наш файл в ветке develop, а применив изменения из Дельты-2, мы получим наш файл в ветке main. Именно база слияния является для нас самым важным состоянием при разрешении конфликта. Мы можем просмотреть ее, и это сильно поможет нам в понимании, какой из файлов нужно оставить.

Итак, чтобы просмотреть базу слияния, нам нужно поменять настройки Git, указав, что мы хотим, чтобы он выводил базу слияния при файловом конфликте. Сделать это можно уже знакомой командой git config.

```
$ git config --global merge.conflictstyle diff3
```

Попробуем прервать слияние и снова выполнить его, чтобы Git составил для нас уже новый файл, в котором он отобразит базу слияния.

```
$ git merge --abort
$ git merge develop
```

А теперь посмотрим на содержимое файла colors.txt.

Содержимое файла colors.txt
```
<<<<<<< HEAD
This color is red,
And this one is blue.
Check out the base
To make conflict solved by you!
||||||| 8b5b982
this color is red
and this one is blue
check out the base
to make conflict solved by you
=======
this color is (255, 36, 0)
and this one is (0, 191, 255)
check out the base
to make conflict solved by you
>>>>>>> develop
```

Видно, что появился новый текст. Все, что находится между ||||||| 8b5b982 и ======= – и есть наша база слияния. Иначе говоря, это содержимое файла из общего родителя двух последних коммитов в ветках main и develop. Кстати, 16-ричное число в строке ||||||| 8b5b982 – это хэш этого родителя, так что при необходимости можно посмотреть на него в логе репозитория.

Теперь изменения в двух файлах нам понятны. В файл в ветке main добавили пунктуационные знаки и заглавные буквы, а в файле в ветке develop названия цветов заменили на их RGB-коды. Теперь мы понимаем, что в итоговом файле должны быть заглавные буквы, пунктуационные знаки и RGB-коды вместо привычных цветов. Итоговый файл выглядит так:

Содержимое файла colors.txt
```
This color is (255, 36, 0),
And this one is (0, 191, 255).
Check out the base
To make conflict solved by you!
```

Просмотр базы слияния очень часто помогает понять, как менялись файлы, и как правильно разрешать конфликты в больших репозиториях.

### Инструменты для разрешения merge-конфликтов.

Существует множество графических инструментов для разрешения файловых конфликтов. Сегодня мы познакомимся с некоторыми. Итак, чтобы запустить графический инструмент для разрешения конфликтов, выполните

```
$ git mergetool
```

При запуске программа спросит вас, какой утилитой вы бы хотели воспользоваться. Доступные варианты: meld, opendiff, kdiff3, tkdiff, xxdiff, tortoisemerge, gvimdiff, diffuse, diffmerge, ecmerge, p4merge, araxis, bc, codecompare, smerge, emerge, vimdiff, nvimdif. У каждой есть свои плюсы и минусы, а в интернете есть множество сравнений этих утилит. Так что оставляем выбор на ваш вкус. После выбора утилиты, откроется она сама. В ней вы сможете просмотреть подсвеченные изменения в конфликтных файлах в удобном формате, а затем внести необходимые изменения, чтобы разрешить конфликт.

Использование графических утилит особенно удобно при сравнении больших файлов: почти во всех есть подсветка внесенных изменений, что поможет вам не запутаться в файле. Тем не менее при сравнении маленьких файлов часто можно обойтись одной консолью. Кстати, большинство IDE имеет встроенную утилиту для разрешения конфликтов, что сделает вашу работу с кодом еще более удобной.

Подведем итог
1. git merge – команда, выполняющая слияние веток.
2. Иногда во время слияния возникают конфликты, в этом случае действовать нужно так:
2.1. Разрешить конфликт.
2.2. После устранения конфликта нужно добавить изменения в индекс командой git add <имя файла>.
2.3. Выполнить git merge --continue, чтобы сообщить Git, что можно продолжать слияние, либо просто сделать коммит самостоятельно.
2.4. Не забывать, что в любой момент можно выполнить git merge --abort. Эта команда остановит слияние и вернет все, как было.
3. Разрешить конфликт можно двумя способами:
3.1. Выбрать файл с целевой ветки или со сливаемой ветки, выполнив, соответственно, git checkout --ours <имя файла> или git checkout --theirs <имя файла>
3.2. Открыть сам файл и отредактировать его вручную, записав туда что угодно.
4. В сообщении merge-коммита следует указывать полезную информацию: какие ветки вы слили, по какому принципу вы сливали файлы, если были конфликты, какие изменения внесли и т.д.
5. В случае, если вы работаете с большим репозиторием, коммиты в который делают много разработчиков, при возникновении конфликтов очень полезно будет посмотреть на базу слияния. Она поможет разобраться, как должен выглядеть слитый файл.

## Еще один способ объединения изменений из разных веток. Команда git rebase.

Итак, давайте познакомимся с командой git rebase. Она позволит нам не только объединять изменения с разных веток, но и менять историю репозитория, манипулируя коммитами.

Если говорить кратко, git rebase переносит коммиты текущей ветки на вершину переданной. Но перед тем, как перейти непосредственно к команде, давайте разберем принцип ее действия на примере. Пусть у нас есть репозиторий со следующим графом.

![](../imgs/gitrebase.png)

Если бы мы хотели выполнить слияние ветки develop в ветку main прямо сейчас, мы бы не смогли сделать его в режиме fast-forward. И нам бы пришлось создавать merge-коммит, засоряющий историю репозитория. На помощь приходит git rebase.

Если вы примените команду git rebase main, находясь на ветке develop, репозиторий примет следующий вид.

![](../imgs/gitrebase-2.png)

То есть команда git rebase перенесла коммиты ветки develop так, чтобы ветка develop брала свое начало на последнем коммите main. Попросту говоря, она перенесла коммиты ветки develop на вершину ветки main. Такое состояние очень выгодно нам тем, что в нем уже можно сделать fast-forward слияние. Таким образом, мы избавились от необходимости создания merge-коммита.

**Важно**
Заметьте, что коммиты D-new, E-new и F-new – это не коммиты D, E и F – их хеш-суммы отличаются, но дельты, которые эти коммиты несут в себе, в идеале должны быть одинаковыми.

Теперь, когда мы получили интуитивное представление о работе команды git rebase, давайте рассмотрим ее синтаксис подробнее.

```
Команда git rebase

Что делает
Перемещает все коммиты: от общего коммита двух веток до последнего коммита текущей ветки на вершину переданной ветки.

Ключи
-i
--interative
Эти ключи позволяют нам делать rebase в интерактивном режиме. Мы будем активно пользоваться ими при редактировании старых коммитов.

--abort
Ключ, использующийся только при разрешении конфликтов. Позволяет прервать ребейз и вернуть все к моменту до начала операции.

--continue
Ключ, использующийся только при разрешении конфликтов. Позволяет продолжить ребейз после разрешения всех конфликтов.

--skip
Ключ, использующийся только при разрешении конфликтов. Позволяет пропустить текущий коммит.

Пример
# Переключимся на ветку для разработки
$ git checkout develop
# Перенесем коммиты ветки develop на верхушку ветку main
$ git rebase main
```

Теперь, когда мы познакомились с синтаксисом команды, давайте разберем ее работу поэтапно.
Допустим, есть репозиторий с такой структурой:

![](../imgs/gitrebase-3.png)

Давайте посмотрим, что происходит при выполнении команды

```
$ git rebase main
```

Git rebase выполняет следующие действия:
1. Первым делом, Git находит общий коммит двух веток. В нашем случае это коммит B.
2. После этого Git начинает двигаться от коммита B к положению указателя HEAD, и делает следующее для каждой пары коммитов.
2.1. Вычисляет дельту между B и D: delta_bd = D - B
2.2. Пытается применить дельту к последнему коммиту ветки main. Так получается коммит D-new. Т.е. D-new = C + delta_bd. Если при этом возникает конфликт, Git останавливается, пока мы не разрешим конфликт.
2.3. Вычисляет дельту между D и E: delta_de = E - D
2.4. Применяет эту дельту к коммиту D-new и получает коммит E-new = D-new + delta_de
2.5. Вычисляет дельту между коммитами E и F: delta_ef = F - E
2.6. Применяет вычисленную дельту к коммиту E-new и получает коммит F-new = E-new + delta_ef
3. Переносит указатель ветки develop на коммит F-new.
4. Переносит HEAD на указатель ветки develop.
5. Создает указатель ORIG_HEAD на коммите F.

После выполнения всех вышеуказанных операций, граф репозитория будет выглядеть так.

![](../imgs/gitrebase-4.png)

Как видно из схемы действий, HEAD переносится в самом конце, поэтому если во время выполнения одного из шагов по применению дельты возникнет конфликт, вы обнаружите, что находитесь в состоянии detached head. В это время в вашей рабочей копии будут все изменения дельты, кроме конфликтных. Не стоит пугаться, просто разрешите конфликты, добавьте изменения в индекс и продолжите ребейз командой:

```
$ git rebase --continue
```

Иногда во время выполнения git rebase возможна следующая ситуация. Изменения, например, в коммите D полностью исключают изменения в коммите C. Причем вам нужны изменения именно из коммита C. В таком случае, после разрешения конфликта, вы обнаружите, что изменений в рабочей копии нет. Вы просто удалили все изменения коммита D, оставив только изменения коммита C. В конечном итоге, вы не добавили в рабочую копию ничего нового. В такой ситуации стоит просто пропустить коммит D, то есть не создавать коммит D-new, выполнив

```
 git rebase --skip 
```

во время возникновения конфликта. Также не стоит забывать, что как и с командой git merge, вы в любой момент можете отменить ребейз, выполнив

```
git rebase --abort
```

Эта команда вернет все к состоянию до выполнения git rebase.

Если же вы уже выполнили ребейз, но по какой-то причине решили все вернуть обратно, не стоит переживать - это легко сделать. Git оставил нам указатель ORIG_HEAD на последнем коммите первоначальной ветки develop. Давайте этим и воспользуемся. Итак, чтобы отменить git rebase уже после его завершения, просто выполните:

```
git reset --hard ORIG_HEAD
```

находясь на ветке develop. Как вы помните из прошлого урока, эта команда перенесет наш указатель ветки вместе с HEAD на место указателя ORIG_HEAD, то есть ветка develop начнет указывать на коммит F как и раньше. По сути это и есть отмена действий git rebase.

## Интерактивный git rebase. Редактирование коммитов любой давности.

В предыдущем уроке мы с вами разобрали, помимо прочего, как можно объединить несколько последовательных коммитов в один и как редактировать содержимое и сообщение последнего коммита ветки. Но что если мы хотим отредактировать более ранний коммит? Git предоставляет нам и такую возможность. Правда тут мы воспользуемся небольшой хитростью.

На самом деле git rebase можно выполнять для одной и той же ветки. В обычном режиме это нам ничего не даст, но вот в интерактивном режиме мы сможем поменять сообщения, содержимое и вообще манипулировать коммитами, как нам только вздумается, вплоть до удаления. Давайте на примере разберем, как происходит изменение коммитов. Итак, допустим у нас есть репозиторий, граф которого выглядит так:

![](../imgs/gitrebase-4.png)

Допустим, нам нужно поменять сообщение коммита C. Как это сделать? Давайте попробуем взять все коммиты, начиная с коммита С и заканчивая коммитом Е, и перенести их на вершину той же ветки. Если бы мы не меняли сообщение коммита С, то такая манипуляция ничего не изменила бы. В этом и кроется небольшая хитрость: если мы поменяем коммит С, поменяется его хеш-сумма, и, соответственно, нам придется менять все последующие коммиты. А теперь вспомним, как работает rebase. На каждом шаге она заново вычисляет дельту и создает новый коммит на основе старого. Именно то, что нам нужно. Давайте поменяем сообщение коммита С. Для этого выполним:

```
git rebase -i HEAD~3
```

**Важно**
Заметьте, мы указываем все коммиты не с коммита C, а с коммита B. Если бы мы указали коммиты, начиная с коммита C, git rebase определил бы коммит C, как общий коммит ветки main и нашей подвыборки коммитов, а значит сам коммит C меняться бы не стал. Поэтому нужно указать коммит за один до того, который мы хотим изменить.

Итак, когда мы выполним указанную команду, перед нами в консольном текстовом редакторе откроется примерно такой экран:

```
 GNU nano 4.8                                  /home/smartiqa/Desktop/test/.git/rebase-merge/git-rebase-todo                                            
pick f831285 C
pick c06b382 D
pick 0874316 E

# Rebase f831285..0874316 onto 2a50e6e (3 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
```

Это так называемый TO-DO файл git rebase. В нем мы указываем, как хотим манипулировать коммитами. Чтобы что-то сделать с коммитом, нужно слово pick перед хешем соответствующего коммита заменить на одну из команд. Либо, если команда это позволяет, вставить ее между коммитами. Вы также можете менять порядок инструкций. Данный файл с инструкциями будет выполняться сверху вниз.

Все доступные команды можно посмотреть в документации, мы же разберем только те, которые необходимы, чтобы изменять коммиты:
p, pick <коммит> – просто использовать коммит, ничего не менять
r, reword <коммит> – использовать коммит, но поменять его сообщение
e, edit <коммит> – использовать коммит, но остановить ребейз, чтобы добавить в коммит больше файлов
s, squash <коммит> – использовать коммит, объединив его с предыдущим
f, fixup <коммит> – как squash, но удаляет информацию об объединенном коммите из истории.

В нашем случае, если мы хотим поменять сообщение коммита С, нужно отредактировать файл следующим образом:

```
reword f831285 C
pick c06b382 D
pick 0874316 E

# Rebase f831285..0874316 onto 2a50e6e (3 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
```

То есть мы заменили команду pick на reword напротив коммита С. Сохраняем файл и выходим обратно в консоль. Перед нами сразу же откроется редактор сообщения коммита С. Вводим новое сообщение, сохраняем файл и выходим из редактора. Если мы теперь просмотрим историю, то обнаружим, что сообщение коммита С действительно поменялось, а вместе с ним поменялись и хэши последующих коммитов. Аналогичным образом можно объединять и удалять любые коммиты, а также добавлять в них новые файлы.

При интерактивном ребейзе тоже могут возникать конфликты. В этом случае процедура остановится и Git попросит вас разрешить конфликт. После стандартных процедур по разрешению конфликта можно выполнить git rebase --continue, чтобы продолжить интерактивный ребейз.

В случае, если вы случайно удалили коммит, можно пойти двумя путями:
Если вы все еще выполняете ребейз, следует выполнить git rebase --abort. Эта команда вернет все к первоначальному состоянию.
Если ребейз уже закончен, переместите указатель ветки на вершину исходной последовательности коммитов, выполнив git reset --hard ORIG_HEAD
Как вы могли убедиться, git rebase – очень мощный инструмент, позволяющий манипулировать историей нашего репозитория. Конечно не стоит забывать, что с большой силой приходит и большая ответственность: при неправильном использовании можно потерять коммиты, доступ к которым потом будет трудно восстановить (но, конечно, не невозможно).

Подведем итог
- git rebase – команда, перемещающая все коммиты: от общего коммита двух веток до последнего коммита текущей ветки на вершину переданной ветки.
- Такое перемещение может быть необходимо, чтобы стало возможным слияние в fast-forward режиме.
- Помимо обычного git rebase, существует интерактивный режим этой команды: git rebase -i. В основном им пользуются, чтобы отредактировать, объединить или удалить старые коммиты. Стоит быть осторожным с этой командой, особенно работая в чужих репозиториях: изменение уже записанных в истории коммитов в некоторых случаях может повлечь непредвиденные последствия, поэтому хорошо подумайте, прежде чем выполнять ребейз.


## Берем вишенку с торта. Команда git cherry-pick

Последняя на сегодня команда тоже связана с манипуляцией коммитами в различных ветках. Дело в том, что иногда возникает ситуация, когда изменения внесенные другим разработчиком в своей ветке нужны вам в вашей ветке прямо сейчас. Конечно, можно сделать merge, но это только засорит историю и сломает логику репозитория: зачем делать слияние, если ветка другого разработчика еще к нему не готова. В этом случае нам на помощь придет команда git cherry-pick. Давайте разберемся, как ей пользоваться, а затем подробнее разберем, в каких именно случаях лучше всего применять cherry-pick, а в каких merge.

```
Команда git cherry-pick

Что делает
Берет переданный коммит и создает в текущей ветке его точную копию.
Также в команду можно передать первый и последний коммит последовательности, тогда та же операция будет выполнена для всех коммитов последовательности.

Ключи
-e
--edit
С этим ключом вы сможете отредактировать сообщение коммита.

-n
--no-commit
С этим ключом команда не создаст коммит на вашей ветке, а только скопирует все изменения в вашу рабочую копию. То есть с этим ключом данная команда идентичная git checkout <коммит> *

--abort
Ключ, использующийся только при разрешении конфликтов. Позволяет прервать операцию и вернуть все к моменту до начала операции.

--continue
Ключ, использующийся только при разрешении конфликтов. Позволяет продолжить операцию после разрешения всех конфликтов.

Пример
# Находясь на основной ветке
$ git cherry-pick 48efdd9
[main 6905e02] Add main.py
Author: @Smartiqa <info@smartiqa.ru>
Date: Sat Apr 10 20:42:22 2021 +0300
1 file changed, 1 insertion(+)
create mode 100644 main.py
```

Никаких особых тонкостей или подводных камней данная команда не имеет. Это действительно мощный инструмент, который поможет вам в работе, однако не всегда хорошо использовать именно cherry-pick. Из-за чрезмерного использования этой команды у вас могут возникнуть коммиты-дубликаты, а история репозитория станет абсолютно нечитаемой. Поэтому нужно хорошо понимать, в каких случаях использовать cherry-pick, а в каких – merge. Всего можно выделить три случая, когда нужно использовать именно cherry-pick, а не merge. Давайте рассмотрим их по очереди.

1. Случай первый. Работа в команде.
Этот случай был описан во введении к данной части. Часто в команде несколько разработчиков работают над одним и тем же участком кода, но каждый – в своей ветке. Соответственно могут возникать ситуации, когда одному из разработчиков для реализации своей части задачи потребуется часть кода, написанная другим разработчиком. Merge в данном случае делать нерационально, поскольку ни одна из веток не пришла к своему логическому завершению, а вот cherry-pick – то, что надо.

2. Случай второй. Быстрые исправления багов.
Если в коде был обнаружен баг, очень важно как можно быстрее донести исправления до конечного пользователя. В таком случае, разработчик, обнаруживший ошибку, срочно создает коммит, в котором исправляет ее. Этот коммит может быть перенесен в основную ветку с помощью cherry-pick, чтобы не задерживать исправление бага слияниями в различные пре-релизные ветки.

3. Случай третий. Восстановление утерянных коммитов.
Иногда возникают ситуации, когда вы из-за каких-то манипуляций потеряли определенный коммит. Например, сделали git reset --hard, начали новую ветку, сделали несколько коммитов и только тут обнаружили пропажу. С помощью git log и git reflog вы можете узнать хеш утерянного коммита, а затем выполнить git cherry-pick, чтобы вернуть его обратно.

Конечно, случаи описаны довольно расплывчато, и дают лишь рекомендации по использованию cherry-pick. Тем не менее, даже эти простые рекомендации помогут вам избежать злоупотребления этой командой и сохранят историю вашего репозитория в чистоте и порядке.

##### <a name="Glava_6"> # Глава 6. Работа с удаленным репозиторием. Модель ветвления. Команды: clone, fetch, push, pull.

## Что такое удаленный репозиторий

Сегодня мы познакомимся с новым понятием: удаленный репозиторий. В прошлых уроках, преимущественно в практических частях, мы уже не раз затрагивали некоторые команды для работы с удаленным репозиторием, но не говорили о них подробно. Пора это исправить!

**Важно**
Отметим, что здесь и далее, в качестве примера, мы будем использовать сервис хостинга удаленных репозиториев GitHub. Мы предпочитаем этот сервис за его популярность и множество дополнительных функций, о которых будет рассказано ниже. Тем не менее, если вам больше нравится другой сервис, процесс работы не будет сильно отличаться.

Для начала давайте повторим информацию из предыдущих уроков.
Распределенная система контроля версий – такая система, в которой участники хранят у себя на компьютере полную копию всех версий проекта. Такой принцип делает их независимыми от рабочего сервера.
Git относится к распределенным системам контроля версий.
Чтобы вы точно вспомнили, приведем диаграмму из первого урока:

![](../imgs/gitremote.png)

Возможно у вас возникнет вопрос: при чем здесь удаленные репозитории? Все просто: сервер по центру диаграммы и есть удаленный репозиторий. Дадим более точное определение.

```
Удаленный (иногда говорят "внешний") репозиторий – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
```

Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории .git/refs/remotes/<имя_удаленного_репозитория>.

**Кстати**
Принято называть удаленные ветки (то есть ветки удаленных репозиториев), приписывая к их названию имя удаленного репозитория. Например, если у нас есть удаленный репозиторий с именем origin и веткой main, то мы будем называть такую ветку origin/main. То же мы будем делать и со всеми остальными ссылочными объектами. Это может показаться излишним, но на самом деле это добавляет определенности и позволяет не запутаться в многочисленных названиях веток.

Как мы уже говорили в первом уроке, один из плюсов распределенной системы контроля версий заключается в том, что у вас может быть сколь угодно много удаленных репозиториев. Какие-то из них могут быть доступны только на чтение, а какие-то – на чтение и запись.

Таким образом, чтобы стать полноценным пользователем Git, важно овладеть навыками работы с удаленным репозиторием. Среди них – создание новых и копирование к себе уже существующих удаленных репозиториев, загрузка на сервер локальных коммитов и скачивание изменения с сервера. Давайте изучим все это по порядку.

## Настройка подключения удаленного репозитория. Группа команд git remote.

Необходимость подключить удаленный репозиторий к уже существующему локальному возникает в ситуациях, когда вы решаете выгрузить уже написанный код на удаленный сервер. Это нужно, чтобы другие разработчики смогли получить к нему доступ или чтобы вы сами могли заниматься разработкой с нескольких компьютеров (например, домашнего и рабочего).

Для управления подключением удаленных репозиториев в Git предусмотрена целая группа команд – git remote. Мы рассмотрим самые частоиспользуемые команды из этой группы.

### Добавление удаленного репозитория к существующему локальному. Команда git remote add.

Давайте разберемся, как добавить удаленный репозиторий к вашему локальному репу. Для этого в Git есть команда git remote add.

```
Команда git remote add

Что делает
Подключает удаленный репозиторий к вашему под переданным именем.

Формат
git remote add <название удаленного репозитория> <ссылка на удаленный репозиторий>

Пример
# Подключим удаленный репозиторий под именем origin 
$ git remote add origin git@github.com:smartiqaorg/geometric_lib.git
```

Возможно у вас возникнут вопросы: что такое имя удаленного репозитория, и откуда взять ссылку на него. Ответим на них по порядку.

**Имя удаленного репозитория** в команде git remote add вы можете придумать сами. Впоследствии, при работе с этим удаленным репозиторием, вы будете обращаться к нему по придуманному имени. Принято называть удаленный репозиторий origin, но строго говоря, никаких ограничений здесь нет.

**Со ссылкой на удаленный репозиторий** тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку Code на странице репозитория на GitHub.

![](../imgs/gitremote-2.png)

Вам предложат выбрать одну из трех ссылок: для протоколов https и ssh и для клиента GitHub на компьютер. Вот примеры этих трех ссылок для репозитория geometric_lib известного вам по практическим занятиям этого курса:

HTTPS-ссылка: https://github.com/smartiqaorg/geometric_lib.git
SSH-ссылка: git@github.com:smartiqaorg/geometric_lib.git
GitHub CLI ссылка: gh repo clone smartiqaorg/geometric_lib

Давайте разберемся, в чем отличие. Начнем с последней - эта ссылка используется в клиенте GitHub, который нужен для упрощения работы с Git. Этот клиент можно поставить отдельно, но его возможности значительно ограничены по сравнению с консольным вариантом Git.

Итак, с последней ссылкой все понятно: ее нужно использовать в специальной программе для компьютера с графическим UI от создателей GitHub. Но в чем разница между первыми двумя?

Дело в том, что существует два основных протокола подключения к git-серверу: HTTPS и SSH. SSH считается более надежным, но он немного сложнее в настройке. Давайте разберемся, как настроить подключение для каждого из них. А окончательный выбор протокола оставим на вкус читателя.

### Настройка подключения по HTTPS

Раньше можно было подключаться по HTTPS, используя имя пользователя и пароль от аккаунта GitHub. Но потом эту возможность отключили в целях безопасности. Сейчас вместо пароля нужно использовать персональный токен. Давайте разберемся, как создать такой токен.

Итак, чтобы создать токен персонального доступа, следуйте инструкции:
1. Подтвердите свой email-адрес, который вы использовали при регистрации аккаунта GitHub (если он не подтвержден
2. Кликните на свою аватарку в правом верхнем углу, в открывшемся окне выберите Settings (Настройки):
3. Перед вами откроются настройки. В меню слева выберите Developer settings (Настройки разработчика)
4. Перед вами откроются Настройки разработчика. В меню слева выберите Personal access tokens (токены персонального доступа).
5. Нажмите Generate new token (сгенерировать новый токен)
6. Придумайте имя для своего токена. Имя должно описывать, зачем токен был создан.
7. Дайте токену разрешения. Пользователь токена сможет выполнять с удаленным репозиторием только то, что вы указали в этих разрешениях. Чтобы дать токену доступ к управлению удаленным репозиторием из командной строки, выберите repo.
8. Нажмите Generate token (сгенерировать токен).
Пример токена
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
9. Скопируйте токен. В целях безопасности, как только вы покинете страницу создания токена, вы больше не сможете просмотреть этот токен.

3 картинки

Отлично, ваш токен готов! При первой загрузке/скачивании изменений из удаленного репозитория, вас попросят ввести имя пользователя на GitHub и пароль. Нужно будет ввести свое имя пользователя, а вместо пароля вставить этот токен.

### Настройка подключения по SSH

Чтобы настроить подключение по SSH, вам нужно на своем компьютере сгенерировать два SSH-ключа: публичный (public) и секретный (private).

**Немного про SSH**
Как работает SSH протокол и зачем ему ключи? Если коротко, то публичный ключ передается на удаленный сервер, а секретный все время остается с вами. Удаленный сервер использует публичный ключ, чтобы удостовериться, что у вас действительно есть секретный ключ. Как только сервер убеждается в наличии у вас секретного ключа, он понимает, что вы – это вы, ведь секретный ключ нельзя подделать.

После создания пары ключей, надо добавить секретный ключ в SSH-агента.

**Про SSH агента**
SSH-агент – это специальная программа, которая сохраняет пароль от файла с секретным ключом и помогает удаленному серверу удостовериться, что вы действительно владеете секретным ключом. Благодаря SSH-агенту, вам не потребуется при каждом подключении к удаленному серверу вводить пароль от файла с приватным ключом.

После останется только загрузить наш публичный ключ на GitHub и готово. Давайте рассмотрим этот процесс подробнее:

1. Откройте Git Bash (или терминал, если вы работаете на Linux/MacOS)
2. Выполните в нем команду `ssh-keygen -t rsa 4096 -C "<ваша-почта>@example.com"`
2.1. Вам предложат ввести путь к директории, в которой будет сохранен ключ, а также будет выведена директория для сохранения по умолчанию. Нажмите Enter, чтобы выбрать директорию по умолчанию, либо введите любую другую директорию и тоже нажмите Enter.
2.2. Затем вам предложат ввести пароль для файла с секретным ключом. Нажмите Enter, чтобы оставить файл без пароля, либо введите пароль и нажмите Enter.
3. Теперь нужно добавить ключ в SSH-агента. Запустим агента командой `eval ssh-agent -s`
4. Теперь выполните команду ssh-add <путь до приватного ключа>. Если вы оставили путь по умолчанию, ваша команда будет выглядеть так: `ssh-add ~/.ssh/id_ed25519`
5. Отлично, последний этап: добавляем публичный ключ на GitHub. Для этого откройте файл с публичным ключом (он должен иметь расширение .pub). Если вы оставили путь по умолчанию, то ваш ключ будет располагаться по адресу ~/.ssh/id_ed25519.pub.
6. Скопируйте содержимое файла.
7. Перейдите в настройки GitHub
8. Откройте раздел SSH and GPG keys (ssh и gpg ключи)

![](../imgs/gitremote-4.png)

9. Нажмите New SSH key (новый ssh-ключ)
10. В поле Title (заголовок) введите содержательное название ключа, например ключ для ноутбука или ключ рабочего компьютера

![](../imgs/gitremote-5.png)

11. Скопированный ключ вставьте в раздел Key (ключ)
12. Нажмите Add SSH key (добавить ssh-ключ)
13. Возможно потребуется ввести пароль для подтверждения действия.

Теперь SSH-ключ добавлен. Вам больше не нужно вводить имя пользователя и пароль при каждой загрузке или скачивании изменений из удаленного репозитория.

### Отключение удаленного репозитория от локального. Команда git remote remove.

Иногда возникает необходимость забыть удаленный репозиторий. Для этого существует команда git remote remove.

```
Команда git remote remove

Что делает
Отключает переданный удаленный репозиторий от вашего.

Формат
git remote remove <название удаленного репозитория>

Пример
# Отключим удаленный репозиторий с именем origin
$ git remote remove origin
```

Данная команда предельно проста в использовании. В качестве имени репозитория нужно передавать то имя, которое вы указывали в команде git remote add. Заметьте, данная команда не удаляет удаленный репозиторий с сервера, она удаляет только подключение вашего репозитория к удаленному.

### Изменение имени удаленного репозитория. Просмотр всех удаленных репозиториев. Команды git remote rename, git remote show.

Иногда возникает необходимость переименовать удаленный репозиторий. Для этого существует команда git remote rename.

```
Команда git remote rename

Что делает
Меняет имя переданного удаленного репозитория

Формат
git remote rename <старое имя удаленного репозитория> <новое имя удаленного репозитория>

Пример
# Переименуем удаленный репозиторий с origin на upstream
$ git remote rename origin upstream
```

Еще более частая задача – просмотреть список всех подключенных удаленных репозиториев и получить информацию о каждом из них. Для этого существует команда git remote show.

```
Команда git remote show

Что делает
Выводит список всех подключенных удаленных репозиториев. Если передано имя репозитория, то выводит информацию об этом репозитории.

Формат
git remote show [имя удаленного репозитория]

Пример
# Выведем список всех удаленных репозиториев
$ git remote show
origin
upstream
# Выведем информацию про репозиторий origin
$ git remote show origin
* remote origin
Fetch URL: git@github.com:smartiqaorg/geometric_lib.git
Push URL: git@github.com:smartiqaorg/geometric_lib.git
HEAD branch: develop
Remote branch:
develop new (next fetch will store in remotes/origin)
Local ref configured for 'git push':
dev pushes to develop (up to date)
```

Таким образом можно просмотреть информацию о каждом из подключенных удаленных репозиториев.

## Клонирование удаленного репозитория. Команда git clone.

Теперь, когда мы разобрались с настройкой подключения удаленного репозитория к уже существующему, давайте узнаем, как можно склонировать удаленный репозиторий к себе на компьютер. Операция клонирования создаёт на вашем компьютере точную копию удаленного репозитория.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда git clone.

```
Команда git clone

Что делает
Клонирует переданный репозиторий на ваш компьютер.

Формат
git clone <ссылка на удаленный репозиторий>

Пример
# Склонируем себе репозиторий geometric_lib
$ git сlone https://github.com/smartiqaorg/geometric_lib.git
```

Ссылку на удаленный репозиторий можно получить тем же способом, что мы разбирали выше. Нужно нажать на зеленую кнопку Code на главной странице репозитория на GitHub.

Заметьте, что клонирование по https возможно вообще всегда, а по ssh – нет. Чтобы клонировать репозитории по ssh, нужно, чтобы владелец удаленного репозитория на GitHub добавил к себе публичный ssh-ключ из пары, в то время, как секретный ssh-ключ от той же пары хранится у вас на компьютере, с которого вы выполняете git clone. Таким образом, если вы настроили ssh в своем аккаунте, то вы сможете беспрепятственно клонировать свои репозитории и по https, и по ssh. Но если вы пытаетесь клонировать чужой репозиторий по ssh, то скорее всего получите ошибку доступа.

**Важно**
Окончательный выбор протокола для клонирования, конечно, остается за читателем. Работать по https проще и быстрее, зато он считается менее защищенным, чем ssh, который в свою очередь труднее в настройке.

Давайте на примере разберем, как происходит клонирование. Клонируем уже знакомый нам репозиторий geometric_lib. При выполнении команды git сlone https://github.com/smartiqaorg/geometric_lib.git произойдет следующее:
1. В директории, откуда вы запустили команду git clone, создается директория с именем репозитория. В нашем случае, если мы выполнили команду из директории пользователя, будет создана папка C:\users\smartiqa\geometric_lib\.
2. В созданную директорию копируется репозиторий, все его ветки и коммиты.
3. В новосозданный локальный репозиторий добавляется удаленный репозиторий с именем origin и ссылкой, которую мы передавали в git clone. Это избавляет нас от необходимости вручную писать git remote add origin https://github.com/smartiqaorg/geometric_lib.git. На этом процесс клонирования заканчивается.

**Кстати**
Вместо git clone можно было бы создать пустой локальный git-репозиторий, выполнив команду git init. Затем подключить наш удаленный репозиторий командой git remote add origin https://github.com/smartiqaorg/geometric_lib.git. После чего вручную загрузить изменения с удаленного репозитория командой git pull, которую мы рассмотрим ниже. Но зачем делать что-то вручную, если для этого есть автоматизированный инструмент из коробки.

## Получение изменений из удаленного репозитория. Команда git fetch

Теперь, когда мы научились подключать удаленный репозиторий к локальному и клонировать его к себе на компьютер, пора узнать, как же получить изменения из удаленного репозитория.

У вас может возникнуть вопрос: зачем получать изменения, если только я загружаю их в свой удаленный репозиторий? Все верно, если вы работаете один, то вряд ли вам пригодится загружать изменения из удаленного репозитория в локальный. Но если вы работаете в команде, вы будете по несколько раз в день обновлять свой репозиторий, загружая в него коммиты, сделанные другими разработчиками из вашей команды.

Итак, чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда git fetch.

```
Команда git fetch

Что делает
Получает изменения из переданного удаленного репозитория. Если не было передано ни одного удаленного репозитория, ни ключа --all, команда пытается получить изменения из репозитория с именем origin.

Формат
git fetch [ключи] [имя удаленного репозитория]

Ключи
--all
Получает изменения из всех подключенных удаленных репозиториев.
Другие ключи

Пример
# Получим изменения из удаленного репозитория
$ git fetch origin
```

Важным замечанием здесь станет то, что команда не обновляет рабочую копию в соответствии с удаленным репозиторием. Она обновляет только ссылочные объекты (указатели, ветки и теги) и скачивает все необходимые файлы в директорию .git/objects.

Давайте рассмотрим пример, чтобы разобраться, что на самом деле делает git fetch. Допустим, у нас есть репозиторий, к которому подключен удаленный репозиторий. Структура рабочих копий и логи выглядят следующим образом:

```
Локальный репозиторий
├── alpha.txt
└── num.txt

* 47573c7 | 2021-05-10 | Initial commit | [Smartiqa] |  (HEAD -> dev, origin/develop)
Удаленный репозиторий
├── alpha.txt
├── new_file.txt
└── num.txt

* b9ad22e | 2021-05-10 | New commit | [Smartiqa] |  (HEAD -> develop, origin/develop)
* 47573c7 | 2021-05-10 | Initial commit | [Smartiqa] |
```

Как видно, в удаленном репозитории есть один коммит, которого нет у нас. В этом коммите был добавлен файл new_file.txt. Кроме того видно, что наша копия удаленной ветки origin/dev находится на первом коммите, хотя должна быть на втором. Чтобы обновить информацию для этой ветки, нам и понадобится git fetch. Выполним команду git fetch origin:

```
$ git fetch origin
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 287 bytes | 143.00 KiB/s, done.
From github.com:smartiqaorg/test-repo
   47573c7..b9ad22e  develop -> origin/develop
```

В выводе команды видно, что она скачала несколько объектов, а из последней строчки мы узнаем, что ветка develop удаленного репозитория была записана в ветку origin/develop на нашем компьютере.

Давайте посмотрим, как теперь выглядит история и рабочая копия локального репозитория.

```
Локальный репозиторий
├── alpha.txt
└── num.txt

* b9ad22e | 2021-05-10 | New commit | [Smartiqa] |  (origin/develop)
* 47573c7 | 2021-05-10 | Initial commit | [Smartiqa] |  (HEAD -> develop)
```

На первый взгляд может показаться, что произошло что-то очень странное: новый коммит появился, а файл, который он добавляет – нет. На самом деле, файл тоже появился, просто рабочая копия не была обновлена. Это видно и из истории репозитория: у нас есть две отдельные ветки: develop и origin/develop. Причем указатель HEAD, который, как мы помним, отвечает за состояние рабочей копии, находится на ветке develop. Что ж, давайте попробуем выполнить самое очевидное: переключим HEAD на ветку origin/develop.

```
$ git checkout origin/develop
Note: switching to 'origin/develop'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at b9ad22e New commit
```

Вот это да, мы как-то оказались в состоянии detached HEAD, хотя вроде бы переключались на ветку. Сейчас разберемся с этим, но сначала давайте проверим, обновилась ли наша рабочая копия:

```
Локальный репозиторий
├── alpha.txt
├── new_file.txt
└── num.txt
```

Все как мы и ожидали, новый файл появился в рабочей копии. Но почему мы оказались в состоянии detached HEAD, если переключались на ветку? Все просто: хоть origin/develop и считается веткой, это ветка не нашего, а удаленного репозитория. Если вы сделаете какие-то коммиты или как-то еще попытаетесь изменить ветку origin/develop, все эти изменения будут потеряны при следующем git fetch. Файл .git/refs/remotes/origin/develop, в котором хранится хэш коммита, на который указывает ветка origin/develop, будет просто переписан. В него запишется тот хэш, на который указывает ветка удаленного репозитория. Все коммиты, которые вы самостоятельно сделали на этой ветке, будут утеряны: на них не останется ссылок. Отсюда и состояние detached HEAD.

Но что же делать, – спросите вы, – как объединить две ветки в одну? В прошлом уроке мы изучили специально созданную для этого команду – git merge.

```
# Переключимся обратно на ветку develop
$ git checkout develop
Switched to branch 'develop'
Your branch is behind 'origin/develop' by 1 commit, and can be fast-forwarded.
  (use "git pull" to update your local branch)

# Сольем ветку origin/develop в ветку develop
$ git merge origin/develop
Updating 47573c7..b9ad22e
Fast-forward
 new_file.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 new_file.txt
```

После выполнения git checkout даже сам Git напомнил нам, что наша ветка отстает от origin/develop на 1 коммит. Правда, он посоветовал выполнить git pull вместо git merge, но уже в следующем разделе мы поймем, что это одно и то же.

Кстати, в выводе команды git merge можно заметить, что слияние прошло в fast-forward режиме. Именно поэтому не было создано merge-коммита. На самом деле, слияние удаленной ветки очень часто можно выполнить в fast-forward режиме, но иногда все-таки приходится разрешать конфликты и создавать merge-коммиты.

**Подведем итог**
Команда git fetch используется для синхронизации локальных ссылочных объектов с этими же объектами в удаленном репозитории. Рабочую копию она не меняет.
Чтобы синхронизировать локальную рабочую копию с удаленным репозиторием, нужно слить удаленные ветки в локальные. Сделать это можно уже знакомой командой git merge.

## Получение изменений из удаленного репозитория. Команда git pull

Связкой git fetch && git merge мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она git pull.

```
Команда git pull

Что делает
Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. По умолчанию слияние удаленной ветки с локальной происходит именно в fast-forward режиме, так что включать его специально не требуется

Формат
git pull [ключи] [имя удаленного репозитория]
Ключи
--ff
--no-ff
--ff-only
Эти ключи определяют стратегию слияния. --ff – включить fast-forward, если это возможно, --no-ff – отключить fast-forward, а --ff-only – остановить pull, если его невозможно сделать в fast-forward.
Другие ключи

Пример
# Обновим нашу рабочую копию в соответствии с удаленным репозиторием
$ git fetch origin
```

На самом деле, новых команд здесь нет. Команда git pull это просто сокращение последовательного применения git fetch и git merge. Но используется git pull намного чаще.

**Подведем итог**
Команда git pull используется для синхронизации локальной рабочей копии и всех ссылочных объектов с удаленным репозиторием.
По сути, git pull - это то же самое, что git fetch + git merge.

## Отправка изменений в удаленный репозиторий. Команда git push

Мы знаем почти все про удаленный репозиторий. Осталось изучить, как загружать в него свои локальные изменения. Для этого в Git существует команда git push.

```
Команда git push

Что делает
Загружает изменения в удаленный репозиторий. Если слияние изменений в удаленном репозитории нельзя сделать в режиме fast-forward, и при этом не был передан ключ force, выполнение закончится с ошибкой.

Формат
git push [ключи] [имя удаленного репозитория] [имя ветки]

Ключи
--all
Пушит все имеющиеся ветки

-f, --force
Перезаписывает удаленную ветку, вне зависимости от ее содержимого. Старайтесь не использовать этот флаг без крайней необходимости.

--force-with-lease
Удаляет все коммиты, которых нет в локальном репозитории. Если коммит, который команда соберется удалять был создан другим пользователем, то выполнение закончится с ошибкой.
Другие ключи

Пример
# Загрузим все изменения с текущей ветки в удаленный репозиторий
$ git push origin develop
```

По факту данная команда аналогична связке git fetch + git merge, но выполненной из удаленного репозитория (это просто аналогия, на самом деле так сделать не получится).

Давайте более подробно разберем, как работает эта команда. Допустим, мы выполнили git push origin develop в нашем локальном репозитории. Возможны три варианта развития событий.

Если изменения с нашей ветки можно слить с удаленной веткой в режиме fast-forward, то есть на удаленной ветке нет коммитов сделанных после наших, то все пройдет нормально.

Если на удаленной ветке есть коммиты, которые были сделаны позже наших, то есть слияние в режиме fast-forward выполнить невозможно, то команда завершится с ошибкой. Ведь в этом случае есть угроза перезаписи истории удаленного репозитория и удаления всех коммитов, созданных позже наших.

Но если вы вдруг передали флаг --force, то все коммиты, которых нет в вашем локальном репозитории, будут удалены. То есть удаленный репозиторий станет точной копией вашего локального. Есть более щадящая версия этого флага – --force-with-lease. Он будет делать в точности то же самое, но если вдруг нужно будет удалить коммит, созданный не вами, выполнение немедленно прекратится и вернется ошибка. Таким образом, вы не попадете в ситуацию, когда вы случайно удалили чужой коммит.

## GitHub. Работа с репозиторием, создание форков и пулл-реквестов

Научившись работать с локальным репозиторием, освоим основы работы с GitHub. Итак, если коротко, то GitHub – это, наверное, самый популярный сервис бесплатного хостинга удаленных репозиториев с множеством дополнительных функций. Среди них есть, например, создание issue – запросов, в которых можно сообщить разработчикам об ошибках, создание репозиториев-форков и пулл-реквестов. Кроме того, на GitHub можно подписаться на обновления какого-то конкретного пользователя или включить отслеживание репозитория вашего любимого проекта. Все это превращает GitHub в настоящую социальную сеть для разработчиков по всему миру. Давайте приступим к изучению основ работы с этим сервисом.

### Создание репозитория на GitHub

Прежде всего вам необходимо зарегистрироваться на GitHub, но это довольно тривиальный процесс, так что его мы здесь опустим. После регистрации вы попадете на главную страницу. На ней будут отображаться действия людей, на которых вы подписались и обновления в репозиториях, которые вы добавили в избранное.

Чтобы создать свой репозиторий, нажмите на зеленую кнопку New, как показано на рисунке.

![](../imgs/gitremote-6.png)

Перед вами откроется страница создания репозитория. Давайте разберем, что за поля нам предлагают заполнить.

1. Итак, первое поле Repository name – имя репозитория. Здесь все просто, вам нужно придумать имя, которое будет отображаться на странице вашего репозитория. Здесь нет никаких ограничений, но старайтесь давать как можно более содержательные имена своим репозиториям.
2. Второе поле – Description – описание. Его заполнять необязательно. Но другим пользователям, которые попали на страницу вашего репозитория, будет проще понять, что перед ними, если вы заполните графу описания.
3. Затем вы можете выбрать, будет ли репозиторий открытым, то есть доступным абсолютно всем пользователям GitHub, или закрытым, то есть доступным только вам и людям, которым вы предоставите доступ.
4. Последние три поля предлагают нам добавить, соответственно, README-файл, .gitignore файл и выбрать лицензию для нашего проекта.

После заполнения полей страница выглядит примерно так.

![](../imgs/gitremote-7.png)

Заметьте, мы не стали вводить описание репозитория, поскольку решили добавить в него README-файл, хотя иногда и можно продублировать самую основную информацию из README в описании.

Завершим процесс создания репозитория, нажав кнопку Create repository.

### Страница репозитория на GitHub.

После создания репозитория, мы попадем на его страницу на GitHub. В нашем случае эта страница будет выглядеть так.

![](../imgs/gitremote-8.png)

Как видно из рисунка, GitHub автоматически создал первый коммит, добавив в него файл .gitignore и файл README.

Кстати, можно заметить, что содержимое файла README выводится под рабочей копией репозитория. Это одна из особенностей GitHub. Вы в любое время можете создать файл с именем README.md и запушить его в свой удаленный репозиторий на GitHub. Тогда содержимое этого файла будет отображаться прямо на странице вашего репозитория.

В верхнем меню мы видим 9 разных вкладок. Давайте разберем их по порядку.

1. Вкладка Code. Сейчас открыта именно она. В ней содержится рабочая копия нашего репозитория (по центру), описание (справа), вывод файла README (под рабочей копией), история коммитов, а также кнопки для клонирования репозитория и просмотра файлов.
2. Вкладка Issues. В этой вкладке будут отображаться все запросы, сделанные другими пользователями. Как правило, пользователи используют запрос, чтобы сообщить о найденном баге, либо чтобы задать какой-то вопрос о вашем приложении.
3. Вкладка Pull-requests. На этой вкладке будут отображаться все пулл-реквесты, сделанные другими пользователями. О том, что такое пулл-реквесты, мы поговорим ниже.
4-5. Вкладки Actions и Project относятся скорее к системе CI/CDI, которую предоставляет GitHub, в этом курсе мы не будем затрагивать их.
6. Вкладка Wiki открывает вам доступ к созданию и размещению документации о собственном проекте.
7. На вкладке Security содержатся различные настройки безопасности вашего проекта. Там же можно включить инспекцию вашего кода, чтобы узнать, если вы случайно загрузите какой-нибудь секретный токен на GitHub.
8. Вкладка Insight содержит различную информацию и статистические данные об активности репозитория. Там вы сможете посмотреть на зависимость количества коммитов в репозитории от времени или на процент коммитов, сделанных вами.
9. Последняя вкладка – Settings. В ней находятся различные настройки вашего репозитория. Там вы можете поменять видимость репозитория, сделав его частным, или вовсе удалить репозиторий.

### Создание форка репозитория на GitHub. Пулл-реквесты.

Итак, одной из самых важных частей GitHub является создание форков.

**Форк** (от англ. fork – вилка) – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.

**Пулл-реквест** (от англ. pull-request – запрос pull) – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.

Если коротко, форки и пулл-реквесты нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на GitHub. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей. Таким образом, даже если ваши изменения не примут, вы получите первоклассный code-review с указанием всех неточностей.

Теперь давайте рассмотрим пайплайн контрибуции (англ. contribution – внесение вклада) на примере реального репозитория. То есть научимся вносить свой вклад в разработку проектов с открытым исходным кодом на GitHub.

1. Для начала зайдем на страницу репозитория проекта. Нажимаем на кнопку Fork, как показано на картинке. После этого Git создаст точную копию этого репозитория в вашем аккаунте.

![](../imgs/gitremote-9.png)

![](../imgs/gitremote-10.png)

2. Клонируем репозиторий к себе на компьютер командой git clone. Создадим файл README.md с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.

3. Сделаем коммит и выполним git push, чтобы загрузить наши изменения в удаленный репозиторий.

4. Теперь GitHub подсказывает нам, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать пулл-реквест.

![](../imgs/gitremote-11.png)

5. Нажимаем на кнопку Compare на подсказке GitHub, либо переходим на вкладку Pull Requests и нажимаем New pull request.

![](../imgs/gitremote-12.png)

6. Перед нами откроется страница создания пулл-реквеста.

![](../imgs/gitremote-13.png)

Здесь мы можем просмотреть внесенные изменения и выбрать две ветки: одну в исходном репозитории, на нее будут залиты наши изменения, вторую – в нашем репозитории, с нее будут скачаны изменения. Как только мы выбрали ветки и убедились, что не внесли никаких лишних изменений, нажимаем кнопку Create pull request.

7. Теперь мы попадаем на страницу описания наших изменений.

![](../imgs/gitremote-14.png)

Здесь необходимо описать, что за изменения вы внесли и почему они были необходимы. Сообщение, которое оставили мы, видно на картинке. Оно отражает суть и необходимость внесенных изменений. Как только мы закончили с описанием, можно нажимать кнопку Create pull request.

8. Теперь мы попадаем на страницу уже созданного пулл-реквеста в изначальном репозитоии. В нашем случае он выглядит так.

![](../imgs/gitremote-15.png)

Именно так будет выглядеть наш пулл-реквест и для владельца репозитория. На этой странице он сможет писать комментарии, указывая на ошибки или задавая вопросы. После того, как владелец репозитория просмотрит наши изменения и убедится, что они не имеют вредоносный характер, он сможет принять наш пулл-реквест. Тогда все изменения, добавленные в этот пулл-реквест нами, будут залиты в исходный репозиторий.

**Подытожим**
Таким образом, вы можете вносить свой вклад в абсолютно любые приложения с открытым программным кодом. Даже репозиторий самого Git хранится на GitHub, и вы в любой момент можете сделать форк и придумать новую команду (правда не факт, что ответственный примет ваш пулл-реквест). Вы можете внести свой вклад в разработку ядра Linux, в популярный редактор Visual Studio Code, в ядро криптовалюты Bitcoin, в языки программирования Python, Go, Ruby – все эти проекты имеют открытые репозитории на GitHub.

## Модель ветвления Git

В этом разделе мы познакомимся с наиболее удачной моделью организации ветвления в большом проекте.

### Центральный репозиторий

Итак, основой нашей модели будет центральный репозиторий. Строго говоря, в Git не может быть никаких центральный репозиториев, поскольку это распределенная система контроля версий. Поэтому центральный репозиторий является таковым только с точки зрения логики его использования, с технической же точки зрения – это точно такой же репозиторий, как и все остальные. У каждого из разработчиков в команде есть копия основного репозитория. Схематически ситуация выглядит так.

![](../imgs/gitremote-16.png)

Центральный репозиторий на картинке назван origin. Как мы уже упоминали выше, это одно из общепринятых наименований в Git.

Процесс разработки построен на том, что каждый разработчик пушит свой код в основной репозиторий и пуллит код других разработчиков из него. Кроме того, допускаются ситуации, когда разработчики обмениваются кодом друг с другом, – минуя центральный репозиторий. Необходимость такого обмена может возникнуть, когда, например, два девелопера работают над одной функцией. В таком случае им необходим код друг друга, но пушить не готовую функцию в основной репозиторий ни один из них не может. Взаимодействие между разработчиками и основным репозиторием изображены на картинке выше с помощью стрелок.

### Основные ветки

В нашей модели существуют две главные ветки:
1. main – ветка, в которой содержится только код, готовый к релизу.
2. develop – ветка, в которой содержатся изменения, готовые ко включению в последующий релиз.

Эти ветви называются главными, поскольку существуют в центральном репозитории и всех его копиях все время. Логика работы с ними не предполагает их удаления после выпуска очередного релиза, в отличие от, например, вспомогательных ветвей группы release.

Как только в ветке develop появляется достаточно изменений для создания нового релиза, она вливается в ветку main (напрямую или посредством создания специальной ветки release-*, о которой мы поговорим позже). После чего соответствующий коммит слияния в ветке main помечается тегом с указанием версии релиза (напомним, что тег – это статический указатель, нужный для удобства переключения между коммитами).

Таким образом, коммит в ветке origin/main означает выпуск нового релиза. Кстати, если строго придерживаться этого правила, можно организовать непрерывную интеграцию при помощи как встроенных средств GitHub, так и сторонних инструментов, специализирующихся на CI/CDI.

### Вспомогательные ветки

Чтобы поддерживать независимость разработки отдельных частей проекта, наша модель включает в себя несколько групп вспомогательных ветвей. Главное отличие таких ветвей от главных в том, что срок жизни этих ветвей ограничен. После завершения выполнения определенной работы, вспомогательная ветвь вливается в одну из главных, после чего удаляется.

Наша модель предполагает существование следующих групп вспомогательных ветвей:
- Ветви для разработки новых функций. Они же feature branches.
- Ветви релизов, то есть release branches.
- Ветви срочных исправлений – hotfix branches.

Чуть ниже мы разберем предназначение каждой группы. Кроме того, мы договоримся о правилах создания, именования и слияния ветвей из каждой группы. Конечно, Git не ограничивает ни в именах ветвей, ни в чем либо другом, – эти условности мы придумываем сами. Тем не менее, такие правила необходимы для облегчения взаимодействия нескольких разработчиков внутри одного большого проекта.

### Feature-ветки

Могут порождаться от: develop
Могут вливаться в: develop
Правило именования: любое имя, кроме main, develop, release-*, hotfix-*.

Ветки функциональности используются для разработки новых функций, для которых неизвестно: будут ли они добавлены в ближайший релиз или же в какой-то более поздний. Основной смысл такой ветки в том, что живет она ровно столько, сколько продолжается разработка функции, для которой была создана эта ветка. В это время в ветке main могут выходить релизы, не затрагивающие разрабатываемую функцию. По завершении создания функции, такая ветка либо вливается в ветку develop, либо удаляется, если эксперимент с новой функцией не удался.

Feature-ветки существуют в основном только в репозиториях разработчиков, но могут на некоторое время появиться и в центральном репозитории.

Графически взаимодействие разработчика с feature-веткой выглядит примерно так:

![](../imgs/gitremote-17.png)

Создать feature-ветку можно следующим образом:

```
# Переключимся на главную ветвь develop
$ git checkout develop
# Создадим feature-ветку
 $ git checkout -b new-feature
```

После завершения работы над функцией, вы можете выполнить слияние и Push:

```
# Переключимся на главную ветвь develop
$ git checkout develop
# Сольем нашу feature-ветку явным образом
 $ git merge --no-ff new-feature
# Удалим нашу feature-ветку
 $ git branch -d new-feature
# Выполним пуш изменений в основной репозиторий
 $ git push origin develop
```

Заметьте, мы специально выполнили merge в режиме non-fast-forward. Дело в том, что хоть fast-forward и удобнее в некоторых случаях, в данном все же лучше использовать явное слияние. Явное слияние позволяет сохранить информацию о том, что ветка new-feature существовала, и объединяет все ее коммиты в один merge-коммит. Впоследствии это позволит разобраться, какие коммиты отвечают за добавление одних и тех же функций. Кроме того, сливая ветку явным образом, мы оставляем себе обходной путь: отменить такое слияние намного проще, чем отменять слияние fast-forward.

### Release-ветки

Могут порождаться от: develop
Могут вливаться в: develop, main
Правило именования: release-*

Ветки релизов необходимы для подготовки к выпуску новых релизов вашего продукта. Их главное назначение – внести финальные штрихи перед выпуском новой версии. В этих ветках можно вносить небольшие изменения и подготавливать файлы с метаданными о версии вашего продукта. Release-ветку следует создавать в тот момент, когда ваш проект готов или почти готов к выпуску очередной версии. По крайней мере не раньше, чем вся функциональность, предназначенная к выходу в этом релизе, будет влита в ветку develop.

Решение о номере версии релиза принимается только после создания release-ветки и опирается на принятые в компании правила нумерации версий. До тех пор неясно, будет ли новый релиз иметь версию 4.1.5, 4.2 или 5.0. Создать release-ветку можно следующим образом.

```
# Переключимся на главную ветвь develop
$ git checkout develop
# Создадим release-ветку
 $ git checkout -b release-4.2
```

Заметьте, мы приняли решение, что новая версия будет иметь номер 4.2, а потому создали ветку с именем release-4.2. Работая в этой ветке, мы можем исправить незначительные ошибки и внести метаинформацию о версии проекта в соответствующие файлы. Обратите внимание, что на этой ветви запрещено вносить какие-то крупные изменения или исправлять серьезные ошибки, ее предназначение не в этом.

Как только все файлы вашего проекта будут готовы к выпуску релиза, данную ветвь можно слить в основную ветку main, что и будет соответствовать выпуску релиза. После чего нужно пометить релиз соответствующим тегом, чтобы впоследствии к нему было проще обращаться. Важно не забыть слить изменения с release-ветки в ветку develop, чтобы вернуть наши незначительные изменения в процесс разработки следующего релиза.

```
# Переключимся на основную ветвь main
$ git checkout main
# Сольем в нее нашу release-ветку
$ git merge --no-ff release-4.2
# Присвоим коммиту тег
$ git tag -a v4.2
# Переключимся на основную ветку develop
$ git checkout develop
# Сольем в нее нашу release-ветку, чтобы вернуть внесенные изменения в разработку
$ git merge --no-ff release-1.2
# Теперь можно удалить release-ветку
$ git branch -d release-1.2
```

### Hotfix-ветки

Могут порождаться от: main
Могут вливаться в: develop, main
Правило именования: hotfix-*

Ветки срочных исправлений или hotfix-ветки, нужны для внесения срочных исправлений в уже вышедший релиз. Такую ветку необходимо создать в ситуации, когда в недавно вышедшем релизе был обнаружен серьезный баг. Предназначение этой ветки – исправить ошибку в последнем вышедшем релизе, а затем выпустить новый релиз, слив ветку hotfix в main и develop. Смысл создания отдельной ветки в том, что работа большей части команды может продолжаться над выходом нового стабильного релиза на ветке develop, пока bugfix-команда работает над исправлением ошибки в последнем релизе в ветке hotfix.

Чтобы создать hotfix-ветку, выполните:

```
# Переключимся на главную ветвь main
$ git checkout main
# Создадим hotfix-ветку для последнего релиза
 $ git checkout -b hotfix-4.2.1
```

Последний релиз имеет номер 4.2, поэтому мы приняли решение, что релиз с исправлением бага в релизе 4.2 будет иметь версию 4.2.1.

После внесения всех необходимых исправлений, нужно слить hotfix-ветку в ветку main, чтобы выпустить новый релиз, и в ветку develop, чтобы наши изменения сохранились в следующем релизе. Сделаем это.

```
# Переключимся на основную ветвь main
$ git checkout main
# Сольем в нее нашу hotfix-ветку
$ git merge --no-ff hotfix-4.2.1
# Присвоим коммиту тег
$ git tag -a v4.2.1
# Переключимся на основную ветку develop
$ git checkout develop
# Сольем в нее нашу hotfix-ветку, чтобы сохранить исправление бага в следующем релизе 
$ git merge --no-ff hotfix-4.2.1
# Теперь можно удалить hotfix-ветку
$ git branch -d hotfix-4.2.1
```

**Подытожим**
Модель, показанная нами выше, не является абсолютно новой. Тем не менее, в проект, разработка которого ведется в соответствии с данной моделью ветвления, очень легко вникнуть. У каждой ветки здесь есть свое строго регламентированное назначение, благодаря чему и достигается интуитивное понимание процесса разработки.
